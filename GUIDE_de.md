# Eine Anleitung zum GitHub Code Vault

## Einleitung

Dieses Archiv, das GitHub Code Vault, wurde vom GitHub-Archiv-Programm etabliert und weitergeführt. Die Mission des GitHub Code Vaults ist, Open Source Software für zukünftige Generationen zu erhalten. Sie könnten dies in einem Jahr lesen oder in eintausend Jahren, aber so oder so hoffen wir, dass Ihnen der Inhalt oder das allgemeine Konzept von Open Source Software nützlich sein wird.

Dies ist in erster Linie ein Archiv von Software. Software ist eine Reihe an Befehlen, um die Aktionen von Computern zu kontrollieren. Ein Computer ist ein Gerät, das mathematische Funktionen automatisch und so viel schneller als ein menschliches Gehirn ausführen kann, sodass er Fähigkeiten hat, die weit über unsere hinausreichen. Unsere Computer werden genutzt um zu helfen, die Geheimnisse des Universums zu ergründen, um die gesamte Menschheit in einem allgegenwärtigen Informationsnetz zu verbinden, um Signale schnell genug zu erzeugen, sodass Töne übertragen und detaillierte bewegte Bilder auf elektrische Bildschirme projiziert werden können, und um gewaltige Maschinen zu steuern, die sowohl die Kapazität als auch die Präzision menschlicher Arbeit weit übertreffen.

Ein Computer ohne Software kann keines dieser Dinge. Ein Computer ist eine außergewöhnliche und wunderbare Sache, aber ohne Software ist all seine Leistung nutzlos. Der Zweck dieses Archivs ist, das, was wir über Software wissen, an Sie weiterzugeben.

Open Source Software ist keine andere Art von Software, aber unter einer anderen Gesinnung. Software wird als komplexe, aber für Menschen lesbare Abfolge von Befehlen verfasst, deren verschiedene Varianten als Programmiersprachen bezeichnet werden. Eine vollständige Softwareeinheit wird oft als Programm bezeichnet. Diese Programme werden dann in Binärsprache umgewandelt, die aus 1en und 0en besteht und von Computern benutzt wird. Dieser Prozess wird Kompilieren genannt.

Da es sehr schwer ist, kompilierte Software zurück in seine ursprünglichen Form (auch bekannt als Quellcode) zu bringen, ist es möglich die ursprüngliche Form geheim zu halten und sie als Eigentum zu beanspruchen. Der Open Source Gedanke lehnt diese Art von Geheimnissen und Beanspruchung ab. Open Source Software wird für alle die sie nutzen möchten, kostenfrei zur Verfügung gestellt, sodass diese die Software verbessern können oder nutzen können, um etwas Neues und Besseres zu erschaffen.

Ein Open Source Softwareprojekt ist eine kollektive Arbeit einer sich selbst organisierenden Gemeinschaft, welche tausende Mitwirkende beinhalten kann. Alle Open Source Projekte, die hier archiviert sind, sind die Arbeit einer Gemeinschaft von vielen Millionen Menschen. Während einige Personen spezielle Rechte innerhalb eines Projektes, wie die Akzeptierung oder Ablehnung vorgeschlagener Änderungen zur aktuellen Version des Quellcodes besitzen, gibt es niemals einen Besitzer davon. Jede Person hat das Recht, jederzeit ohne Kosten oder Strafe eine vollständige Kopie eines Open Source Projektes anzufertigen. Dieser Vorgang wird 'Forking' eines Projektes genannt.

Wenn viele Leute zur selben Zeit an Quellcode arbeiten, ist es schwierig alle ihre Änderungen zu verfolgen und sie ins Projekt zu integrieren. Ein Open Source Projekt, das Git genannt wird zur Lösung dieses Problems verwendet. Es integriert eine vollständige Historie über alle Ergänzungen und Änderungen zu einem Projekt in eine sogenannte Git Repository. Dieses Archiv ist im Wesentlichen ein Archiv solcher Repositories. 

 Was folgt ist eine Beschreibung, wovon wir glauben, was Sie wissen müssen um den besten Nutzen aus diesem Archiv zu ziehen. Wenn Sie etwas nicht kennen oder verstehen sollten, verzweifeln Sie nicht! Wir haben ebenfalls eine Anleitung beigefügt, die erläutert, wie Sie diese Voraussetzungen erfüllen können. Wenn Sie die diese aus irgendeinem Grund nicht erfüllen können, geben Sie sie bitte an Ihre Nachkommen weiter.

## Was wird benötigt um dieses Archiv zu verwenden

Im Prinzip ist alles was Sie benötigen, um auf die Inhalte dieses Archivs zuzugreifen eine Lichtquelle und ein Werkzeug zur Vergrößerung. Die meisten (wenn auch nicht alle) Daten wurden sehr stark verkleinert auf diese 200 Filmrollen in kodierter und komprimierter Form gespeichert. Lesen, dekodieren und dekomprimieren dieser Daten wird ebenfalls beträchtliche Rechenleistung in Anspruch nehmen. Theoretisch könnte dies auch ohne Computer geschehen, dies wäre jedoch umständlich und schwierig.

Unsere Erwartung ist, dass Sie die Definitionen von Software, Computer und weitere nicht benötigen werden. Wir könnten uns vorstellen, dass Sie Ihre eigenen Computer besitzen, möglicherweise weit fortgeschrittener als unsere und möglicherweise vollständig anders aufgebaut. Wenn Sie die Einleitung und die Anleitung unten begriffen haben, werden Sie in der Lage sein, einfach an all diese Daten zu gelangen.

Auch ist es möglich, dass Sie Computer besitzen, die unseren unterlegen sind oder Sie gar keine Computers zur Verfügung haben. In diesem Fall, haben wir eine unkomprimierte, unkodierte und für Menschen lesbare Datenrolle, die wir den Tech Tree nennen. Der Tech Tree enthält Informationen über unsere fundamentalen Technologien, unsere Computer und unsere Software, in der Hoffnung, dass Sie mit weiterem Fortschreiten der Zeit irgendwann in der Lage sein werden, dieses Wissen zu nutzen um Computer nachzubauen, die ermöglichen können, einen Nutzen aus diesem Archiv zu ziehen.

## Was ist enthalten

Dieses Archiv ist so groß -- ungefähr 24 Billionen Bytes -- da es extrem inklusiv und demokratisch ist. Viele Millionen Menschen machen die Software, die sie schreiben für jedermann verfügbar. Dieses Archiv enthält einen Schnappschuss -- das ist eine Kopie eines Momentes -- aller öffentlichen Software, die die Nutzer von GitHub aktiv entwickeln. Das bedeutet, dass es mehrere Zehnmillionen separaten Repositories enthält. Unsere Hoffnung ist, dass dieser weitreichende, demokratische Ansatz interessant für Historiker in der Zukunft sein könnte.

Es ist klar, dass nicht alle diese Repositories gleichermaßen wichtig bezüglich Einfluss und Abhängigkeit sind. Der Tech Tree enthält ein Verzeichnis und eine kurze Beschreibung der signifikantesten Repositories innerhalb des Archivs und listet auf, welche auf welcher Rolle gefunden werden kann, sodass diese erreicht werden können, ohne alle dieser Millionen von Repositories durchstöbern zu müssen, um die nützlichsten herauszufiltern.

## Ein Überblick über das Archiv

Das Archiv besteht aus 201 Filmrollen: Eine 'Anleitungsrolle' mit menschenlesbaren Informationen und Anleitung, 200 Rollen von archivierter Software. Jede Rolle enthält 65.000 einzelne Frames. Die Frames am Beginn jeder Rolle und die auf der Anleitungsrolle enthalten menschenlesbaren Text und Bilder. Alle anderen Frames bestehen aus digitalen Daten, die als QR-Code gespeichert wurden.

Digitale Daten sind Daten, die im Binärformat gespeichert werden, z.B. als 0en und 1en, da Computer selbst binär funktionieren -- kontrolliert durch elektrische Signale, die entweder 'an' oder 'aus' sind, dies entspricht 1 und 0 -- und somit werden binäre Daten erheblich einfacher als alles Andere von Computern verstanden.

Die menschenlesbaren Metadaten, die am Anfang jeder Rolle gespeichert sind, enthalten Informationen über den Film selbst, eine Anleitung für die QR-Kodierung, ein Softwareprogramm um diese zu dekodieren und einen Inhaltsverzeichnis. Das Inhaltsverzeichnis listet den Titel, die Nummer des Anfangsframes und die Prüfsumme für jede Datei auf, die auf der jeweiligen Rolle gespeichert sind.

Eine Datei ist ein einzelnes, zusammenhängendes Datenobjekt. Eine Prüfsumme ist ein einzigartiger Wert, der als Ergebnis einer Berechnung hervorgeht, die Hash-Funktion genannt wird und die mittels des Inhaltes der gesamten Datei einen Wert berechnet um zu gewährleisten, dass die Inhalte nicht beschädigt oder defekt sind. Die verwendete Hash-Funktion wird SHA-1 genannt.

Jeder QR-Code besteht aus einem Feld aus kleinen weißen und schwarzen Quadranten, welche fast die gesamte Fläche des Films bedecken. Wir nutzen QR-Codes, da diese wesentlich kompakter und robuster als menschenlesbarer Text sind. Ein QR-Code wird zu Binärdaten dekodiert z.B eine Reihe von 0en und 1en.

Diese Dekodierung ist nur der erste Schritt um diese binären Daten zu sinnvollen Informationen umzuwandeln. Es handelt sich um komprimierte Daten, was bedeutet, dass es verdichtet wurde, um Speicherplatz zu sparen. Ähnlich zur Schreibweise '128xA' anstatt 128 mal den Buchstaben 'A' zu schreiben. Nachdem die Daten dekodiert wurden, müssen sie dekomprimiert werden.

Das Resultat nach der Dekomprimierung nennt sich Archiv-Datei: Eine einzelne Datei, die sämtliche Inhalte einer einzelnen Software Repository enthält. Die meisten Repositories enthalten viele Dateien, sodass diese Archiv-Datei wie ein Buch aussieht, das viele separate Kapitel enthält, oder eine Kiste, die viele weitere Kisten enthält. Es ist generell vorteilhaft, wenn nicht absolut notwendig, diese Archiv-Datei in ihre Einzelteile zu entpacken, bevor auf diese zugegriffen wird.

Jede Unterdatei ist eine eigene Sammlung binärer Daten, das heißt 0en und 1en. Es kann Sinn ergeben, wenn Sie das Format der Daten kennen. Zum Beispiel werden beim Format 'UTF-8', das meinstverwendete Format innerhalt dieses Archivs, die 1en und 0en in Gruppen von acht Stellen zerteilt, die Bytes genannt werden. Das Byte 01000001 repräsentiert den Buchstaben A; die drei Bytes 01101001 01101110 01110100 repräsentieren das Wort 'int' und die beiden Bytes 11000011 10000011 repräsentieren den Buchstaben Ã (A mit einer Tilde darüber).

Dieser Datenarchivierungsprozess (Binär-Dateien, die in Archiv-Dateien verpackt und anschließend erst komprimiert und danach QR-Kodiert werden) ist offensichtlich komplex, verglichen mit menschenlesbarem Text. Der umgekehrte De-Archivierungsprozess (QR zu komprimierter Binärdatei, komprimiert zu unkomprimiert, Archiv-Datei zu mehreren Dateien, Textdateien zu menschenlesbaren Text) ist ähnlich komplex. Diese Komplexität erlaubt es uns, erheblich mehr Daten in einer für Computer verständlichen Art zu speichern, als sonst möglich gewesen wären.

Falls diese Komplexität zu schwierig oder kostspielig für Sie sein sollte, tut es uns Leid. Unsere Erwartungen sind, dass diese Anleitung und er Tech Tree in diesem Fall die Komplexität reduzieren und vielleicht nützlicher für Sie sind als die Inhalte des Archivs, zumindest bis Ihre Computer gut genug sind, um einfach mit der Komplexität dieser Archivdaten umzugehen.

## Dateien, Verzeichnisse, Repositories und andere Datenformate

Es könnte aufschlussreich sein zu wissen, wie das Archiv logisch aufgeteilt ist. Insbesondere eine Diskussion über Dateien, Verzeichnisse und Datenformate ist vermutlich hilfreich.

Eine Datei ist eine Sammlung von Daten, die gruppiert in einem zusammenhängenden Objekt unter einem Namen gespeichert werde: Denken Sie an Daten als Sand und eine Datei als eine Art Tasche welche den Sand (und nur Sand) beinhaltet. Ein Verzeichnis ist eine Sammlung von Dateien: Denken Sie an eine Tasche, welche nur andere Taschen beinhalten kann. Ensprechend dieser Metapher, besteht jede Repository aus einem äußeren Verzeichnis, bekannt als das Wurzel-Verzeichnis, welches eine Anzahl von Dateien und/oder anderer Verzeichnisse enthält. Jedes Verzeichnis kann wiederum weitere Dateien und Ordner enthalten.

Diese Struktur wird bevorzugt, da die Arbeit mit gruppierten Dateien um Einiges einfacher ist als mit einer einzigen Sammlung an Dateien. Die Identifizierung einer Datei innerhalb eines äußeren Verzeichnisses, besteht aus den Namen aller sie einschließenden Verzeichnisse, beginnend mit dem Wurzelverzeichnis, endend mit dem eigenen individuellen Namen der Datei und jeweils abgetrennt durch ein /-Zeichen. Ein Beispiel: Eine Datei mit dem Namen README.md im Wurzelverzeichnis würde als /README.md identifiziert werden. Eine Datei, die mit /public/www/index.html indentifiziert wird, würde der Datei index.html im Verzeichnis 'www' entsprechen, das wiederum im Verzeichnis 'public' im Wurzelverzeichnis liegt.

Jede Repository besitzt zwei aufeinanderfolgende Namen, die durch ein Trennzeichen getrennt werden. Dieses Trennzeichen ist in diesem Archiv ein _ oder Unterstrich. (Historisch war es zuerst ein / oder Slash, jedoch wird dies ebenfalls verwendet um Verzeichnisse anzugeben, daher verwenden wir _ um klarheit zu schaffen.) Der erste Name ist der des GitHub Kontos, der die Repository besitzt; der zweite ist der Name der jeweiligen Repository. Die Kombination aus Repository- und Datei-Bezeichner sind einzigartig und können verwendet werden um eine Datei im Archiv eindeutig zu identifizieren. Beispielsweise kann die Datei 'package.json' im Verzeichnis 'web' im Repository 'ykarma' mit dem Eigentümer 'rezendi' eindeutig als /web/package.json in rezendi_ykarma bezeichnet werden.

Verschiedene Arten von Dateien haben verschiedene Zwecke. Das GitHub-Archiv besteht zum größten Teil aus Textdateien. Das bedeutet, dass die Dateien geschriebene Sprache beinhalten. Die meiste Software wird in Textdateien geschrieben, die hochstrukturierten Text enthalten, der Quellcode genannt wird. Ein spezielles Programm, das Compiler genannt wird, konvertiert diesen menschenlesbaren Quellcode zu computerlesbaren Anweisungen, bekannt als kompilierter Code oder Maschinencode.

Dateien, die nicht Textdateien sind, z.B. Dateien, die visuelle Bilder oder kompilierten Quellcode enthalten, bezeichnet man häufig als Binärdateien. Dies ist unglücklicherweise ein irreführender Begriff, da auch Textdateien letztendlich 0en und 1en sind. Dateien die keine Textdateien sind, werden als Nicht-Textdateien bezeichnet.

Es gibt viele Möglichkeiten, um geschriebene menschliche Sprache in 0en und 1en umzusetzen. Aus historischen Gründen wird der größte Teil des Quellcodes ursprünglich in Latin Alphabet geschrieben. Das Latin Alphabet besitzt 26 Basiszeichen, welche dafür da sind, gesprochene Worte zu bilden. Jedes Zeichen hat hierbei zwei Formen: Groß und klein. Ebenfalls gibt es 10 Ziffern, um Zahlen zu bilden. Das Latin Alphabet wird (inklusive verschiedener anderer Symbole) verwendet, um Strukturen und andere Konzepte anzugeben. Um die Zeichen zu 0en und 1en zu kodieren wird ein Format namens ASCII verwendet, welches 128 verschiedene Zeichen darstellen kann und sich aus historischen Gründen über viele Jahre hinweg  bei Softwareprojekten durchgesetzt hat.

Das Latin Alphabet ist nur einer von vielen Möglichkeiten, wie Menschen sich in geschriebener Sprache ausdrücken. Um andere Alphabete zu unterstützen, wobei weiterhin alle ASCII-Software ohne weitere Änderungen lauffähig blieben (ein Konzept namens Abwärtskompatibilität), wurde ein anderes Datenformat mit dem Namen UTF-8 eingeführt.

ASCII bleibt das meistverbreitetste Format von Quellcode. Jede Rolle dieses Archivs enthält eine Anleitung für ASCII-Zeichen. ASCII ist ein Teil von UTF-8, womit alle ASCII-Kodierungen auch UTF-8-Kodierungen sind. Die Anleitungsrolle enthält zusätzlich eine Spezifikation aller UTF-8 Zeichen. Nahezu alle Textdateien in diesem Archiv sollten im UTF-8 Format kodiert sein.

Nicht-Text-Dateien enthalten Dateien um Bilder und formattierte Dokumente zu repräsentieren. Eine weitverbreitete Konvention ist, dass eine Datei mit einem . Zeichen, gefolgt von einem Suffix endet, welches den Typen angibt. Wenn beispielsweise eine Datei mit .jpg endet, handelt es sich mit hoher Wahrscheinlichkeit um eine JPEG-Bilddatei; Eine die mit .png endet, ist mit hoher Wahrscheinlichkeit eine Bilddatei vom Typ 'Portable Image Graphic'; und eine die mit .pdf endet, sollte ein formattieres Dokument vom Typ 'Portable Document File' sein.

Es gibt keine einheitliches Suffix, das Textdateien eindeutig identifiziert. Eher markiert das Suffix, um welche Programmier- oder Formattierungssprache es sich beim Quellcode handelt. Programmier- bzw. Formattierungssprachen werden im weiteren Verlauf näher beschrieben.

## Wie die Inhalte des Archivs extrahiert werden können

Im folgenden Teil werden wir einen Überblick bereitstellen, wie einzelne archivierte Repositories in ihre einzelnen Bestandteile zu entpacken sind. Um zu wiederholen, dieser Prozess besteht aus:

1. Identifizierung der Rolle und der Frames, auf welchen die Daten der Repository gespeichert sind.

2. Dekodierung der QR-Codes, den Feldern von schwarzen, weißen und grauen Pixeln auf diesen Frames zu einer binären Datei, einer Reihe von (zumindest tausende, und oft millionen von) 1en und 0en.

3. Dekomprimieren der Binärdateien zu längeren, unkomprimierten Archivdateien.

4. Entpacken der Archiv-Datei zu den einzelnen Dateien, die sie enthält. Beachten Sie dass die Archivdaten generell verständlich sind, sogar wenn dieser Schritt übersprungen wird.

5. Abschließend: Konvertierung von allen Unterdateien -- die lange bzw. kurze Reihen von 1en und 0en enthalten -- zu geschriebenen Zeichen, falls es sich um Textdateien handelt.

### Identifizierung der Rolle und der Frames, auf welchen die Daten der Repository gespeichert sind

Jede Filmrolle beginnt mit einem beginnenden leeren Film und danach einem Null-Referenz-Frame, welches aus einem schwarzen Rechteck in einer Ecke auf dem sonst leeren Frame besteht. Das nächste menschenlesbare Frame ist das Kontroll-Frame mit Informationen über das Rad selbst. Folglich ist dies das Inhaltsverzeichnis, das die Liste der Benutzerdateien enthält.

Jede Repository auf dieser Rolle ist eine dieser Benutzerdateien. Die Liste schließt eine einigartige ID, eine Rollen-ID und ein Name für jede dieser Dateien ein. Zum Beispiel könnte die CPython Repository die Rollen-ID 12345 und den Namen python_cpython.tar haben.

Der Liste aller Benutzerdaten folgt eine Liste von digitalen Daten-Positionen. Diese Liste enthält eine ID, ein Start-Frame, ein Start-Byte, ein End-Frame und ein End-Byte. Wenn wir das hypothetische CPython-Beispiel weiterhin verwenden, könnte das Element mit dem ID 12345 in der Liste ein Start-Frame von 054321, ein Start-Byte von 03210321, ein End-Frame von 054545 und ein End-Byte von 12321232 haben.

Um an die Daten von CPython zu kommen, bedeutet dies: Gehen Sie zum Frame 54321 auf dieser Filmrolle. Dekodieren Sie alle Frames beginnend vom Start-Frame (54321) zu binären Werten, mit den Mitteln die im weiteren Verlauf der Anleitung beschrieben sind. Das Ergebnis werden 224 Datenstücke mit den Nummern von 54321 bis 54544 sein, welches mit einer Reihe von leeren Stücken ohne Daten beginnen wird. Verwerfen Sie die ersten 3210320 Bytes im ersten nicht-leeren Datenstück. Fügen Sie alle Mittelstücke in der richtigen Reihenfolge an. Fügen Sie abschließend die ersten 12321232 Bytes des letzen Datenstücks (54544) hinten an. Sie haben nun die vollständige CPython Repository zu einer komprimierten Archivdatei zusammengebaut.

### Dekodieren von QR-Codes zu einer Binärdatei

Die Details, wie die Film-Frames zu binären Daten dekodiert werden, können in den menschenlesbaren Repräsentationsinformationen auf jeder Rolle des Archivs nach dem Inhaltsverzeichnis gefunden werden. Diese Information ist auf jeder Rolle enthalten, da die Daten des Archivs auch extrahierbar sein sollen, wenn eine Rolle vom Rest des Archivs getrennt wird. Die Repräsentationsinformationen enthalten in folgender Reihenfolge:

1. Eine Anleitung zum GitHub Archiv Programm (dieses Dokument)

2. GitHub Beschreibungsverzeichnis, eine Liste und kurze Beschreibung aller Repositories auf dieser Rolle

3. Repräsentationsinformationenbeschreibung

4. Digitale Konservierung und wie die Daten abgerufen werden können, ein Überblich über Datenempfangsdetails

5. Beschreibung des Speichermediums

6. Technologie zum Datenempfang

7. Generische Konservierungsstruktur der Rollen (Rollenformat)

8. Generische 4K Frame Formatbeschreibung

9. Beschreibung der Entpackungsbibliothek

10. Programmcode der Entpackungsbibliothek

11. ASCII Format-Spezifikation

12. Sprachen-Spezifikation für die Programmiersprache C

13. Programmcode für LZMA / XZ

14. Programmcode für TAR-Archivdateien

15. Programmcode für PDF

16. [Rosetta-Dokument?]

Der sechste dieser Punkte, die Technologie zum Datenempfang, beschreibt die Anforderungen und Prozesse um einen Scanner zu nutzen, um die Daten von einem enkodierten Film-Frame zu lesen und in die Form zu bringen, die durch Computeranalyse veränderbar ist.
