# Eine Anleitung zum GitHub Code Vault

## Einführung

Dieses Archiv, der GitHub Code Vault, wurde vom GitHub Archive Program eingerichtet, dessen Aufgabe es ist, Open Source-Software für zukünftige Generationen aufzubewahren. Sie lesen dies vielleicht in einem Jahr oder in tausend Jahren, aber so oder so hoffen wir, dass der Inhalt und möglicherweise das Konzept von Open Source für Sie nützlich sind.

Dies ist in erster Linie ein Archiv von Software. Software ist eine Reihe von Befehlen, mit denen die Aktionen eines Computers gesteuert werden. Ein Computer ist ein Gerät, das automatisch mathematische Funktionen so viel schneller ausführen kann als ein menschlicher Verstand, dass es weit über uns hinausgehende Kräfte besitzt. Unsere Computer werden verwendet, um die Geheimnisse des Universums zu erforschen, die gesamte Menschheit in einem allgegenwärtigen Informationsnetz zu verbinden, Signale schnell genug zu manipulieren, um Töne zu übertragen und detaillierte bewegte Bilder auf elektrische Bildschirme zu projizieren, und um bis jetzt enorm leistungsfähige Maschinen zu steuern übertrifft sowohl die Kapazität als auch die Präzision menschlicher Arbeit.

Ein Computer ohne Software kann keines dieser Dinge tun. Ein Computer ist eine außergewöhnliche und wunderbare Sache, aber ohne Software ist seine gesamte Leistung nutzlos. Der Zweck dieses Archivs ist es, das, was wir über Software wissen, an Sie weiterzugeben.

Software wird als komplexe, aber für Menschen lesbare Befehlssequenzen geschrieben, deren verschiedene Varianten als Programmiersprachen bezeichnet werden, da eine vollständige Softwareeinheit häufig als Programm bezeichnet wird. Diese Programme werden dann in die Binärsprache der von Computern verwendeten Einsen und Nullen konvertiert. Dieser Vorgang wird als Kompilieren bezeichnet.

Da es sehr schwierig ist, kompilierte Software wieder in ihre ursprüngliche Programmform, auch als Quellcode bekannt, zu entschlüsseln, ist es für Benutzer möglich, diese ursprüngliche Form geheim zu halten und das Eigentum daran zu beanspruchen. Open Source Software ist keine andere Art von Software, sondern ein anderes Ethos. Das Open-Source-Ethos lehnt Geheimhaltung und Eigentum ab. Open-Source-Softwareprogramme werden allen, die sie verwenden möchten, kostenlos zur Verfügung gestellt, damit sie diese Programme verbessern oder etwas Neues und Besseres erstellen können.

Ein Open-Source-Projekt ist die kollektive Arbeit einer sich selbst organisierenden Gemeinschaft, die zu Tausenden zählen kann. Die Ansammlung aller hier archivierten Open-Source-Softwareprojekte ist das Werk einer Community von vielen Millionen. Während bestimmte Personen innerhalb eines bestimmten Projekts besondere Rechte haben können, beispielsweise die Möglichkeit, vorgeschlagene Änderungen an der neuesten offiziellen Version des Quellcodes zu genehmigen oder abzulehnen, besitzt es niemand. Jede Person hat das Recht, jederzeit eine vollständige Kopie eines Open-Source-Projekts ohne Kosten oder Strafe zu erstellen und zu verwenden. Dies wird als Forking eines Projekts bezeichnet.

Wenn viele Leute gleichzeitig am Quellcode arbeiten, ist es schwierig, alle Änderungen zu verfolgen und zu integrieren. Ein Open-Source-Projekt namens "Git" widmet sich der Lösung dieses Problems. Es integriert einen vollständigen Verlauf aller Ergänzungen und Änderungen an einem Projekt in eine Entität, die als Git-Repository bezeichnet wird. Dieses Archiv ist im Wesentlichen ein Archiv solcher Repositories.

Dieses Archiv wurde von einer Firma namens "GitHub" erstellt, die einen Service bietet, mit dem Menschen auf der ganzen Welt die von ihnen geschriebenen Softwareprogramme speichern, Änderungen an diesen Programmen verfolgen und mit anderen zusammenarbeiten können, um sie zu verbessern und zu erweitern. GitHub stellt seine Dienste Entwicklern öffentlicher Open-Source-Software kostenlos zur Verfügung. Es hat zig Millionen solcher Benutzer.

Im Folgenden wird beschrieben, was Sie unserer Meinung nach wissen und haben müssen, um dieses Softwarearchiv optimal nutzen zu können. Wenn Sie etwas oder etwas davon nicht wissen oder verstehen, verzweifeln Sie nicht! Wir haben auch eine Anleitung beigefügt, wie diese Anforderungen erfüllt werden können. Wenn Sie sie aus irgendeinem Grund nicht selbst erreichen können, können es Ihre Nachkommen.

## Was Sie brauchen, um das Archiv zu benutzen

Grundsätzlich benötigen Sie für den Zugriff auf den Inhalt dieses Archivs nur eine Beleuchtungsquelle und eine Art Lupe. Die meisten (wenn auch nicht alle) Daten wurden jedoch in codierter und komprimierter Form sehr dicht auf Filmspulen gepackt. Das Lesen, Dekodieren und Dekomprimieren dieser Daten erfordert selbst erhebliche Berechnungen. Theoretisch könnte es ohne Computer gemacht werden, aber es wäre sehr langweilig und schwierig.

Wir erwarten, dass Sie unsere Definitionen von Software, Computer und anderen Begriffen nicht benötigen. Wir stellen uns vor, Sie haben eigene Computer, die wahrscheinlich weitaus weiter fortgeschritten sind als unsere und möglicherweise grundlegend anders aufgebaut sind. Sobald Sie die folgende Übersicht und Anleitung verstanden haben, können Sie problemlos auf alle Daten zugreifen.

Es ist jedoch möglich, dass Sie minderwertige Computer haben oder gar keine. In diesem Fall haben wir eine unkomprimierte, nicht codierte, für Menschen lesbare Datenrolle vorbereitet, die wir als Tech Tree bezeichnen. Der Tech Tree enthält Informationen zu unseren grundlegenden Technologien, unseren Computern und unserer Software, in der Hoffnung, dass Sie dieses Wissen im Laufe der Zeit nutzen können, um Computer neu zu erstellen, die die Open Source-Software in diesem Archiv verwenden können.

## Was ist da drin

Das Archiv ist so gross - ungefähr 21 Billionen Bytes (siehe unten) -, weil es äußerst inklusiv und demokratisch ist. Viele Millionen Menschen stellen die Software, die sie schreiben, allen zur Verfügung. Dieses Archiv enthält einen Schnappschuss - das heißt eine einzelne Kopie zu einem bestimmten Zeitpunkt - aller öffentlichen Software, die die Benutzer von GitHub aktiv entwickeln. Dies bedeutet, dass es Millionen separater Repositorys enthält. Wir hoffen, dass dieser breite demokratische Ansatz für Historiker der Zukunft von Interesse sein wird.

Die in diesem Archiv enthaltenen Repositorys wurden ausschließlich durch ihre letzte Festschreibungszeit, das heißt die letzte Aktualisierung, und ihre Anzahl der Sterne bestimmt. (Alle Benutzer von GitHub können öffentliche Repositories "markieren", um anzuzeigen, dass sie für sie von Interesse oder Bedeutung sind.) Der Snapshot wurde am 02.02.2020, das heißt am zweiten Tag des Monats Februar, im Jahr 2020 des Gregorianischen Kalenders, seit wir die Zeit zählen. Die darin enthaltenen Repositorys sind: alle Repositorys mit Commits innerhalb der letzten 80 Tage; alle Repositories mit mindestens einem Stern und Commits innerhalb der letzten 365 Tage; und alle Repositories mit mindestens 250 Sternen, unabhängig davon, wann sie zuletzt aktualisiert wurden.

Natürlich sind nicht alle diese Repositories hinsichtlich ihres Einflusses und ihrer Abhängigkeiten gleich wichtig. Der Tech Tree enthält einen Index und eine kurze Beschreibung der wichtigsten Repositorys im Archiv sowie Listen, auf denen sich die einzelnen Repositorys befinden, sodass auf sie zugegriffen werden kann, ohne all diese Millionen von Repositorys durchsuchen zu müssen, um festzustellen, welche am praktischsten sind.

## Ein Überblick über das Archiv

Das Archiv besteht aus 188 Filmrollen: einer "Führungsrolle" mit lesbaren Informationen und Anleitungen, die wir Tech Tree nennen, und 187 Rollen archivierter Software. Jede Rolle enthält 65.000 Einzelbilder. Die Rahmen am Anfang jeder Rolle und die Rahmen der Führungsrolle enthalten für Menschen lesbaren Text und Bilder. Alle anderen Filmbilder bestehen aus digitalen Daten, die in einer visuellen Form gespeichert sind, die als QR-Codes bezeichnet wird.

Digitale Daten sind Daten, die letztendlich im Binärformat gespeichert sind, das heißt als Nullen und Einsen, da die Computer selbst binär sind - gesteuert durch elektrische Signale, die entweder "Ein" oder "Aus" sind, entsprechend 1 oder 0 - und somit Binärdaten sind. Computer sind für Computer weitaus einfacher zu verstehen als alle anderen.

Die für Menschen lesbaren Metadaten, die zu Beginn jeder Rolle gespeichert sind, enthalten Informationen über den Film selbst, eine Anleitung zur verwendeten QR-Codierung, ein Softwareprogramm zum Decodieren und einen Index. Der Index listet den Titel, die Anfangsrahmennummer und die Prüfsumme für jede auf dieser Rolle gespeicherte Datei auf.

Eine Datei ist eine einzelne kohärente Dateneinheit. Eine Prüfsumme ist ein eindeutiger Wert aus einer Berechnung, die als Hash-Funktion bezeichnet wird und über den gesamten Inhalt einer Datei ausgeführt wird, um sicherzustellen, dass der Inhalt nicht beschädigt ist oder beschädigt wurde. Die im Archiv verwendete Hash-Funktion wird als 'SHA-1' bezeichnet.

Jeder QR-Code besteht aus einem Feld winziger weißer oder schwarzer Quadrate, die fast den gesamten Filmrahmen einnehmen. Wir verwenden QR-Codes, weil sie viel kompakter und robuster sind als lesbarer Text. Ein QR-Code decodiert in Binärdaten, das heißt eine Reihe von Einsen und Nullen.

Diese Dekodierung ist nur der erste Schritt, um diese Binärdaten in aussagekräftige Informationen umzuwandeln. Es handelt sich um komprimierte Daten, was bedeutet, dass sie aus Platzgründen komprimiert wurden, ähnlich wie man "128xA" schreiben könnte, anstatt den Buchstaben A 128 Mal zu schreiben. Nach dem Dekodieren muss es dekomprimiert werden.

Das Ergebnis nach der Dekomprimierung wird als Archivdatei bezeichnet: Eine einzelne Datei, die den gesamten Inhalt des Repositorys eines einzelnen Softwareprojekts enthält. Die meisten Repositorys enthalten viele Dateien, daher ähnelt diese Archivdatei einem Buch, das viele separate Kapitel enthält, oder einer Box, die viele andere Boxen enthält. Es ist im Allgemeinen vorteilhaft, aber nicht unbedingt erforderlich, die Archivdatei vor dem Zugriff in ihre Komponentendateien zu entpacken.

Schließlich ist jede Komponentendatei ein eigener Satz von Binärdaten, das heißt Einsen und Nullen. Man kann Daten verstehen, wenn man sein Format kennt. Beispielsweise werden in dem als 'UTF-8' bekannten Format, dem im Archiv am häufigsten verwendeten Format, die Einsen und Nullen in Achtergruppen unterteilt, die als Bytes bezeichnet werden. Das Byte 01000001 repräsentiert den Buchstaben A; die drei Bytes 01101001 01101110 01110100 repräsentieren das Wort int; und die zwei Bytes 11000011 10000011 repräsentieren den Buchstaben Ã (A mit einem Tilde-Akzent oben).

Dieser Datenarchivierungsprozess, bei dem Binärdateien in Archivdateien gepackt werden, die zuerst komprimiert und dann QR-codiert wurden, ist offensichtlich komplex im Vergleich zum einfachen Schreiben von lesbarem Text. Der nicht archivierende Prozess, den Sie durchlaufen müssen - QR zu komprimierter Binärdatei; komprimiert bis unkomprimiert; Datei in mehreren Dateien archivieren; Textdateien zu lesbarem Text - ist ähnlich komplex. Dies liegt daran, dass wir aufgrund dieser Komplexität wesentlich mehr Daten speichern können, als dies sonst möglich wäre, und zwar auf relativ leicht computerlesbare Weise.

Wenn diese Komplexität für Sie schwierig und kostspielig ist, entschuldigen wir uns, aber wir gehen davon aus, dass in diesem Fall dieser Leitfaden und der für Menschen lesbare Tech Tree diese Komplexität verringern und für Sie möglicherweise nützlicher sind als das Archiv Inhalte, zumindest bis Ihre Computer soweit fortgeschritten sind, dass die Komplexität der Archivdaten leicht zu bewältigen ist.

## Dateien, Verzeichnisse, Repositorys und Datenformate

Es kann lehrreich sein, zu diskutieren, wie das Archiv logisch aufgeteilt ist. Insbesondere eine Diskussion von Dateien, Verzeichnissen und Datenformaten dürfte hilfreich sein.

Eine Datei ist eine Sammlung von Daten, die zu einer zusammenhängenden Einheit mit einem einzigen Namen zusammengefasst sind: Stellen Sie sich Daten als Sand und eine Datei als eine Art Beutel vor, der Sand und nur Sand aufnehmen kann. Ein Verzeichnis ist eine Sammlung von Dateien: Stellen Sie sich das als eine Art Tasche vor, die nur andere Taschen aufnehmen kann. Nach dieser Metapher besteht jedes Repository aus einem äußeren Verzeichnis, dem Stammverzeichnis, das eine Reihe von Dateien und / oder eine Reihe von Verzeichnissen enthält. Jedes Verzeichnis kann wiederum sowohl Dateien als auch Verzeichnisse selbst enthalten.

Diese Struktur wird bevorzugt, da in Gruppen organisierte Dateien viel einfacher zu bearbeiten sind als eine einzelne Dateisammlung. Die Kennung einer bestimmten Datei im äusseren Verzeichnis besteht aus den Namen aller umschließenden Verzeichnisse, beginnend mit dem Stammverzeichnis, gefolgt von einem eigenen Namen mit einem / -Zeichen zwischen jedem Namen. Beispielsweise würde eine Datei mit dem Namen README.md im Stammverzeichnis als /README.md und eine Datei mit dem Namen /public/www/index.html als Datei index.html im Verzeichnis 'www' im Verzeichnis 'public' des Stammverzeichnisses identifiziert.

Jedes Repository hat wiederum zwei Namen, die durch einen Teiler getrennt sind, der im Archiv ein _- oder Unterstrichzeichen ist. (In der Vergangenheit war es ein / oder Schrägstrich, aber das wird auch verwendet, um ein Verzeichnis anzugeben, daher verwenden wir aus Gründen der Übersichtlichkeit _.) Der Vorname ist das GitHub-Konto, dem dieses Repository gehört. Der zweite ist der Name des einzelnen Repositorys. Die Kombination aus Repository- und Dateikennungen kann verwendet werden, um eine einzelne Datei im Archiv eindeutig zu identifizieren. Beispielsweise könnte die Datei 'package.json' im Verzeichnis 'web' im Repository 'ykarma' im GitHub-Konto 'rezendi' in rezendi_ykarma im Archiv eindeutig als /web/package.json identifiziert werden.

Verschiedene Arten von Dateien haben unterschiedliche Zwecke. Das GitHub-Archiv besteht größtenteils aus Textdateien, das heißt Dateien, deren Daten die geschriebene Sprache darstellen sollen. Die meiste Software ist in Textdateien geschrieben, die stark strukturierten Text enthalten, der als Quellcode bezeichnet wird. Ein spezielles Programm, das als Compiler bekannt ist, konvertiert diesen für Menschen lesbaren Quellcode in computerlesbare Anweisungen, die als kompilierter Code oder Maschinencode bezeichnet werden.

Dateien, bei denen es sich nicht um Textdateien handelt, z. B. Dateien, die visuelle Bilder darstellen oder kompilierten Code enthalten, werden häufig als Binärdateien bezeichnet. Dies ist leider ein irreführender Begriff, da Textdateien letztendlich auch Einsen und Nullen sind. Wir werden Dateien, die keine Textdateien sind, als Nicht-Textdateien bezeichnen.

Es gibt viele Möglichkeiten, geschriebene menschliche Sprache mit Einsen und Nullen darzustellen. Aus historischen Gründen wurde der größte Teil des Quellcodes ursprünglich in lateinischer Schrift geschrieben. Die lateinische Schrift enthält 26 Grundzeichen, mit denen sprechbare Wörter dargestellt werden, von denen jedes zwei Formen hat: Groß- und Kleinbuchstaben. Es hat auch 10 Ziffern, um Zahlen darzustellen. Die lateinische Schrift wird zusammen mit verschiedenen anderen zugehörigen Symbolen, die zur Angabe der Struktur und anderer Konzepte verwendet werden, in einem als "ASCII" bekannten Format in Einsen und Nullen codiert, das 128 verschiedene Zeichen darstellen kann und aus historischen Gründen in den meisten Programmen viele Jahre lang vorherrschte.

Die lateinische Schrift ist jedoch nur ein winziger Teil der vielen Arten, wie sich Menschen in schriftlicher Sprache ausdrücken. Um andere Skripte zu unterstützen und gleichzeitig zu ermöglichen, dass die gesamte geschriebene Software ASCII ohne Änderungen weiterarbeitet (ein Konzept, das als Abwärtskompatibilität bezeichnet wird), wurde ein anderes Datenformat namens "UTF-8" eingeführt.

ASCII bleibt das häufigste Format für Quellcode. Jede Rolle dieses Archivs enthält eine Anleitung zu ASCII-Zeichen. ASCII ist eine Teilmenge von UTF-8, das heißt alle ASCII-Codierungen sind ebenfalls UTF-8-Codierungen. Die Führungsrolle enthält zusätzlich eine Spezifikation aller UTF-8-Zeichen. Fast alle Textdateien in diesem Archiv sollten als UTF-8 codiert sein.

## So extrahieren Sie den Inhalt des Archivs

Hier geben wir einen Überblick darüber, wie ein bestimmtes archiviertes Repository in seine verschiedenen Bestandteile entpackt wird. Auch dieser Prozess besteht aus:

1. Identifizieren der spezifischen Rolle und Frames, auf denen die Daten des Repositorys archiviert werden.

2. Dekodieren von den QR-Codes, den Feldern der schwarzen, weißen und grauen Pixel in diesen Rahmen, in eine Binärdatei, eine Folge von (mindestens Tausenden und oft Millionen von) Einsen und Nullen.

3. Entpacken Sie die Binärdatei in eine längere, nicht komprimierte Archivdatei.

4. Entpacken Sie die Archivdatei in die darin enthaltenen separaten Unterdateien. Beachten Sie jedoch, dass Archivdaten im Allgemeinen verständlich sind, obwohl sie unübersichtlich sind, auch wenn dieser Schritt weggelassen wird.

5. Konvertieren Sie schließlich jede dieser Unterdateien - selbst Sequenzen von Einsen und Nullen, die von ziemlich kurz bis sehr lang sein können - in geschriebene Zeichen, wenn es sich um Textdateien handelt.

### Identifizieren der spezifischen Rolle und Frames, auf denen die Daten des Repositorys archiviert werden

Jede Filmrolle beginnt mit einem Leiter eines leeren Films und dann mit dem Null-Referenzrahmen, der aus einem durchgezogenen schwarzen Rechteck in einer Ecke eines ansonsten leeren Rahmens besteht. Der nächste für Menschen lesbare Frame ist der Control Frame mit Informationen zur Rolle. Darauf folgt das Inhaltsverzeichnis, das wiederum eine Liste der Benutzerdatendateien enthält.

Jedes Repository auf dieser Rolle ist eine dieser Benutzerdatendateien. Die Liste enthält eine eindeutige ID, eine Datei-ID und einen Namen für jede dieser Dateien. Beispielsweise kann im CPython-Repository des Python-Kontos die Datei-ID als 12345 und der Name als python_cpython.tar aufgeführt sein.

Nach der Liste der Benutzerdatendateien folgt eine Liste der Speicherorte für digitale Daten. Diese Liste enthält die Datei-ID, einen Startrahmen, ein Startbyte, einen Endrahmen und ein Endbyte. Unter Verwendung des hypothetischen CPython-Beispiels kann das Element in dieser Liste mit der ID 12345 einen Startrahmen von 054321, ein Startbyte von 03210321, einen Endrahmen von 054545 und ein Endbyte von 12321232 haben.

So erhalten Sie die CPython-Daten: Gehen Sie zu Bild 54321 dieser Filmrolle. Dekodieren Sie alle Rahmen vom Startrahmen 54321 bis zum Endrahmen 54545 mit den nachstehend beschriebenen Mitteln in Binärwerte. Auf diese Weise erhalten Sie 225 Datenelemente mit den Nummern 54321 bis 54545, die mit einem Satz leerer Daten ohne Daten beginnen. Verwerfen Sie die ersten 3210320 Bytes im ersten nicht leeren Datenelement. Hängen Sie alle "mittleren" Daten nacheinander an. Fügen Sie abschließend die ersten 12321232 Bytes aus dem letzten Datenelement 54545 hinzu. Sie haben jetzt das gesamte CPython-Repository als einzelne komprimierte Archivdatei zusammengestellt.

### Dekodierung aus den QR-Codes in eine Binärdatei

Einzelheiten zum Dekodieren der Filmbilder in Binärdaten finden Sie in den für Menschen lesbaren Darstellungsinformationen, die dem Inhaltsverzeichnis am Anfang jeder Filmrolle im Archiv folgen. Diese Informationen befinden sich auf jeder Rolle, sodass selbst wenn eine einzelne Rolle vom Archiv getrennt ist, der Inhalt entschlüsselt werden kann. Diese Darstellungsinformationen umfassen in der Reihenfolge:

1. Eine Anleitung zum GitHub-Archivprogramm (dieses Dokument)

2. Beschreibender GitHub-Index, eine Liste und eine kurze Beschreibung aller Repositorys auf dieser Rolle

3. Beschreibung der Darstellungsinformationen

4. Digitale Aufbewahrung und Abrufen von Daten, eine Übersicht über Details zum Abrufen von Daten

5. Beschreibung des Speichermediums

6. Datenabruftechnologie

7. Generic Preservation Reel Structure (Rollenformat)

8. Allgemeine Beschreibung des 4K-Frame-Formats

9. Beschreibung der Unboxing-Bibliothek (für die QR-Codes)

10. Quellcode der Bibliothek entpacken

11. Spezifikation des ASCII-Datenformats

12. C Programmiersprachenspezifikation

13. Quellcode der TAR-Archivdatei

14. PDF-Quellcode

15. Spezifikation des XZ-Dateiformats (zur Komprimierung / Dekomprimierung unten beschrieben)

Das sechste dieser Elemente, das Dokument zur Datenabruftechnologie, beschreibt die Anforderungen und Prozesse für die Verwendung eines Scanners, um die Daten auf einem einzelnen digital codierten Filmbild zu erfassen und in eine Form zu verwandeln, die für Computeranalysen geeignet ist. Die achte davon, die Beschreibung des generischen 4K-Frame-Formats, enthält die technischen Informationen, einschließlich des Quellcodes, die ein Computer benötigt, um ein solches gescanntes Bild aufzunehmen und in Binärdaten umzuwandeln.

Grundsätzlich ist es theoretisch möglich, ein Repository von QR-codierten Daten ohne Verwendung eines Computers in Binärdaten umzuwandeln. Es wäre jedoch enorm schwierig und würde wahrscheinlich eine beträchtliche Anstrengung einer gut organisierten Gemeinschaft über viele Wochen, wenn nicht Monate oder Jahre erfordern. Da es sich bei den Inhalten der Repositorys um Software handelt, die auf einem Computer ausgeführt werden soll, ist ihre Verwendung ohne Computer bestenfalls minimal.

Für den Fall, dass die Erben dieses Archivs keine Computer haben, sollten sie das Archiv bis dahin vollständig und sicher aufbewahren. Ein Zweck des für Menschen lesbaren Technologiebaums besteht darin, die Entwicklung von Technologien und Computern in diesem Fall zu beschleunigen. (Sein anderer Zweck ist es, unsere Technologie und ihre Entwicklung für zukünftige Historiker zu kodifizieren.)

### Entpacken der Archivdatei in die darin enthaltenen separaten Unterdateien

Die Binärdatei für jedes Repository hat das Format TAR für Tape Archive. Eine TAR-Datei besteht im Wesentlichen aus der Gruppierung mehrerer Dateien, indem das Ende einer Datei mit dem Anfang der nächsten verbunden wird, z. B. indem einzelne Papierstücke zu einer einzigen Schriftrolle zusammengeklebt werden. Eine TAR-Datei kann eine beliebige Anzahl von Dateien beliebiger Größe enthalten, die in eine beliebige Anzahl von Verzeichnissen und Unterverzeichnissen unterteilt sind.

Jeder Subdatei in einer TAR-Datei wird ein 512-Byte-Header-Datensatz vorangestellt, der sich wie das Band in der Bildlaufmetapher verhält. Dieser Header-Datensatz enthält Informationen zur Datei, z. B. Name und Größe. Das Ende des Archivs wird durch mindestens zwei aufeinanderfolgende 512-Byte-Blöcke angezeigt.

Da TAR-Dateien im Wesentlichen nur Sammlungen von Dateien mit dazwischen liegenden Textdatensätzen sind, kann eine TAR-Datei, die alle Textdateien enthält, als Textdatei selbst behandelt werden. Wenn es eine Mischung enthält, kann es als Textdatei behandelt werden, die eine Mischung aus strukturiertem, aussagekräftigem Text (die Bestandteile der Textdateien) und unverständlichem Kauderwelsch (die Bestandteile der Nicht-Textdateien) enthält.

Es ist möglich, TAR-Dateien in TAR-Dateien zu verschachteln, einen Container in einen anderen, und auf diese Weise werden die meisten unserer archivierten Daten gespeichert. Für ein bestimmtes Repository enthält die äußere TAR-Datei mindestens Folgendes:

* Eine einzelne unkomprimierte Metadatendatei namens META, die den Repository-Namen, den Kontonamen, die Beschreibung, die Sprache, die Anzahl der Sterne und die Anzahl der Gabeln enthält
* Eine komprimierte (siehe unten) Datei mit dem Namen COMMITS, die ein Protokoll der Änderungen enthält, die im Laufe der Zeit am Repository vorgenommen wurden
* Eine Datei mit dem Namen repo.tar.xz, eine komprimierte TAR-Datei, die den eigentlichen Repository-Inhalt enthält

Andere Metadaten wie Wikis, Gh-Seiten, Probleme und Pull-Anforderungen können ebenfalls als separate komprimierte Dateien enthalten sein.

Spezifische Details zu TAR-Dateien und die Software zum Codieren und Decodieren finden Sie in den Darstellungsinformationen auf jeder Rolle des Archivs.

### Komprimierte Dateien in lesbare, nicht komprimierte Dateien entpacken

Um so viele Repositorys und Daten wie möglich einzuschließen, wurden die meisten Daten komprimiert. Komprimierung bedeutet, eine kleine Datenmenge zu verwenden, um eine größere Menge darzustellen, indem Muster und Wiederholungen in dieser größeren Menge verwendet werden. Anstatt das Zeichen neunmal hintereinander zu schreiben, könnte man beispielsweise einfach den komprimierten Text 9a schreiben, wenn man sicher wäre, dass der Leser verstehen würde, dass 9a den unkomprimierten Text aaaaaaaa bedeutet.

Effektive Komprimierungsalgorithmen sind viel komplexer, aber das gleiche Prinzip gilt. Dieses Archiv verwendet ein Komprimierungsprogramm namens "XZ", das wiederum einen Algorithmus namens "LZMA" verwendet. Die zweite Datendatei auf jeder Rolle enthält den Quellcode und die Dokumentation für XZ in einer einzelnen unkomprimierten TAR-Archivdatei, die unten beschrieben wird. (Die erste Datendatei enthält die Allgemeine Erklärung der Menschenrechte in jeder verfügbaren geschriebenen menschlichen Sprache.)

LZMA kombiniert einen sogenannten "LZ77" -Algorithmus und eine "Bereichskodierung". LZ77 ersetzt wiederholte Daten durch Verweise auf frühere Erscheinungen dieser Daten. Um beispielsweise eine 80-Byte-Phrase beim zweiten Mal zweimal im Abstand von 400 Byte zweimal zu vereinfachen, komprimiert der Algorithmus die Daten im Wesentlichen, indem er sagt: "80 Byte von vor 400 Byte wiederholen". Die Bereichskodierung konvertiert im Wesentlichen eine gesamte Nachricht in eine einzelne sehr lange Zahl, die wiederum codiert werden kann.

Die spezifischen Schritte des Algorithmus, der zum Dekomprimieren der Daten verwendet werden soll, werden durch den XZ-Quellcode beschrieben, der in der zweiten Datendatei auf jeder Rolle enthalten ist. Während es theoretisch möglich ist, von Hand zu dekomprimieren, wäre dies wiederum ein außerordentlich zeit- und arbeitsintensiver Prozess. In der Praxis wäre ein funktionierender Computer erforderlich.

### Konvertieren jeder einzelnen Datei in geschriebene Zeichen

Die Menschheit hat im Laufe der Jahrtausende viele geschriebene Zeichen verwendet. Die Codierung, mit der diese Zeichen in diesem Archiv als Einsen und Nullen dargestellt werden, wird als "UTF-8" bezeichnet. Ein einzelnes UTF-8-Zeichen, d. H. Ein einzelnes geschriebenes Symbol, kann 1 bis 4 Bytes Binärdaten belegen.

Aus historischen Gründen wird eine Gruppe von Zeichen (und Konzepten), die als "ASCII" bezeichnet wird, mit 1 Byte pro Zeichen am effizientesten codiert, da sie in der Zeit und Region, in der und zu Beginn der Softwareentwicklung am häufigsten verwendet wurden, am effizientesten codiert wurden. Alles, was nicht ASCII ist, wird als 2 oder mehr Bytes pro Zeichen codiert. Die meisten Textdateien in diesem Archiv sind ASCII-Dateien, eine beträchtliche Anzahl jedoch nicht. Viele weitere sind meistens ASCII-Zeichen mit gelegentlichen Nicht-ASCII-Zeichen.

Die detaillierten Spezifikationen von ASCII finden Sie in den Darstellungsinformationen auf jeder Rolle des Archivs. Die detaillierten Spezifikationen von UTF-8 finden Sie auf der Führungsrolle. Die erste Datendatei auf jeder Rolle des Archivs enthält den Text der Allgemeinen Erklärung der Menschenrechte in jeder verfügbaren menschlichen Sprache. Dies dient sowohl als Übersetzungswerkzeug als auch als Beispiel für ASCII und UTF-8.

## Arten von Dateien

Es gibt viele verschiedene Arten von Textdateien, die aus verschiedenen Gründen erstellt wurden. Die Hauptart hier, der Grund, warum dieses Archiv existiert, ist Quellcode. Der Quellcode ist ein sehr dichter, extrem strukturierter Text, in dem Symbole wie '{' und ';' haben große Bedeutung.

Das Wichtigste am Quellcode ist, dass er so geschrieben ist, dass er von Compilern gelesen werden kann. Da es sich bei Compilern um Software handelt, besteht eine andere Möglichkeit, dies zu formulieren, darin, dass der Quellcode so geschrieben wird, dass er von Computern gelesen werden kann. Guter Code ist auch so geschrieben, dass andere Menschen ihn verstehen können, wenn sie auf dem Gebiet der Software qualifiziert und ausgebildet sind. aber es ist nur richtig, wenn ein Compiler es verstehen kann.

Dieser Compiler konvertiert wiederum durch komplizierte Sequenzen, die im Tech Tree beschrieben sind, den Quellcode in die Sequenzen von Einsen und Nullen, die den Computer veranlassen, die im Code beschriebenen Funktionen und Aktivitäten auszuführen. Um ein sehr einfaches Beispiel zu nennen: die Codezeile

    _for (int i = 0; i <5; i ++) {}_

wird vom Compiler in eine Reihe von binären Anweisungen konvertiert, die dem Computer zugeführt werden, wodurch ein winziger Teil des Computers, der als Register bezeichnet wird, seinen Wert auf 0 setzt und diesen Wert anschließend auf 1, 2, 3 und 4 erhöht. (Dies ist nicht als Beispiel für nützlichen Code gedacht; es ist nur eine Illustration des vielschichtigen Prozesses, Quellcode in laufende Software umzuwandeln.)

Andere Arten von Textdateien wie JSON, XML und HTML werden zum Speichern von Daten (im Gegensatz zu Befehlen) für Computer verwendet. Sie sind im Allgemeinen auch für Menschen lesbar, obwohl sie aufgrund ihrer strukturierten Formate schwerer zu lesen sind als weniger strukturierter Text zum Erzählen von Geschichten wie diese Datei.

Die meisten anderen Arten von Textdateien sollen schließlich von Menschen gelesen werden. Einige sind einfacher, meist unstrukturierter Text, wie diese Datei, die Sie gerade lesen. Eine Art, auf die Sie im Archiv häufig stoßen werden, ist Markdown, gekennzeichnet durch die Erweiterung .md für eine Datei, eine Art Zwischenform, die von Menschen in ihrer Rohform gelesen und gleichzeitig so strukturiert werden soll Computer können sie in optisch ansprechendere und nützlichere Layouts formatieren. Die meisten Repositorys in diesem Archiv verfügen über eine README.md-Markdown-Datei, die im Allgemeinen als erste Einführung in das Repository gedacht ist und beschreibt, was es ist, warum es existiert und wie es verwendet wird.

Ein kurzer Überblick über die gängigsten Formen von Nicht-Textdateien kann ebenfalls hilfreich sein. Kompilierter Code ist kein Text. JPG- und PNG-Dateien codieren Bilder in digitalem Format und MP3 und WAV codieren Audio. PDF-Dateien codieren Dokumente mit präziser, perfekter Formatierung. Und ZIP- und TAR-Dateien sind, wie bereits erwähnt, Containerdateien, die wiederum eine oder mehrere andere Dateien enthalten können.

## Menschliche Sprachen und Programmiersprachen

### Menschliche Sprachen

Es gibt Tausende von Schriftsprachen, die heute von der Menschheit verwendet werden, und noch mehr gesprochene Sprachen. Die meisten davon werden nur von relativ kleinen Bevölkerungsgruppen verwendet, aber es gibt mindestens zwanzig Sprachen, die von mindestens 60 Millionen Menschen als erste oder zweite Sprache verwendet werden.

Die weltweit am häufigsten verwendeten Sprachen sind Englisch und Chinesisch. Aus historischen Gründen fand der größte Teil der Softwareentwicklung über viele Jahre im englischsprachigen Raum statt. Daher wurde Englisch für einige Zeit zur Standardsprache für Software. Die meisten Programmiersprachen verwenden englische Wörter in ihrer Syntax. Es ist die Sprache, in der dieser Leitfaden zum Archiv zuerst geschrieben wurde.

Es kann nicht garantiert werden, dass die Erben dieses Archivs Englisch sprechen, obwohl es eine besonders wahrscheinliche Sprache ist, die auf unbestimmte Zeit Bestand hat. Falls eine Anleitung zu anderen Sprachen hilfreich ist, fügen wir die mehr als 500 verfügbaren Übersetzungen der Allgemeinen Erklärung der Menschenrechte als unkomprimierte UTF-8-Datei zu Beginn jeder Rolle und auch in den Tech Tree ein. Diese Erklärung ist eine Liste der Rechte und Freiheiten jedes einzelnen Menschen in unserer Zeit, die niemals weggenommen werden dürfen.

### Programmiersprachen

Programmiersprachen werden von Menschen verwendet, um Anweisungen an Computer zu übermitteln. Sie sind die Sprachen, in denen Software ausgedrückt wird. Andere (geschulte) Menschen sollten ebenfalls in der Lage sein, die in Programmiersprachen geschriebene Software zu lesen, aber das ist ein sekundäres Ziel.

Eine Programmiersprache ist eine Reihe vordefinierter Elemente, von denen die meisten Wörter sind, die strukturiert angeordnet werden können, um einen Computer anzuweisen, die angegebene Aktion auf die angegebene Weise auszuführen. Eine Sammlung solcher Anweisungen wird als Programm oder als Quellcode bezeichnet. Der Quellcode ist im Wesentlichen Software in eingefrorener, schriftlicher Form.

Programme sind im Allgemeinen in diskrete Schritte unterteilt, die als Anweisungen bezeichnet werden und die wiederum zu Sammlungen zusammengefasst werden, die als Funktionen bezeichnet werden. Ein gesamtes Programm kann in einer einzelnen Datei enthalten sein oder über Tausende verteilt sein.

Es gibt Hunderte verschiedener Programmiersprachen, die auf viele verschiedene Formen, Ansätze und Philosophien verteilt sind. Einige werden in separate Binärdateien kompiliert, die dann ausgeführt werden. Einige, als "interpretierte" Sprachen bekannte Sprachen werden effektiv kompiliert und auf einmal ohne Zwischenphase ausgeführt. Die meisten modernen Programmiersprachen enthalten Bibliotheken mit vorab geschriebenen Funktionen, und solche Bibliotheken können sehr umfangreich und aufwändig sein. Einige der beliebtesten Programmiersprachen von heute sind:

* C, eine der ältesten und schnellsten, universellsten und mächtigsten Sprachen, in mancher Hinsicht einfach, in anderen jedoch recht begrenzt und nicht immer intuitiv, leicht zu lesen oder leicht zu lernen.

* C ++, eine komplexere, abstraktere und mächtigere Entwicklung von C.

* C #, eine weitere Entwicklung, die nicht in binären Maschinencode kompiliert wurde, sondern eine interpretierte "Laufzeit".

* Java, das C # ähnelt (aber älter als C # ist), ist möglicherweise die heute am häufigsten verwendete Sprache.

* JavaScript ist im Gegensatz zu Java trotz der Ähnlichkeit des Namens und auch als "ECMAScript" bekannt eine Sprache, die ursprünglich vollständig in einem Webbrowser verwendet wurde, das heißt ein Programm, das Daten von einem als Internet bezeichneten Remotecomputer abruft, interpretiert und anzeigt Server; Heute ist es jedoch auch auf diesen Servern weit verbreitet.

* TypeScript, eine Form von JavaScript mit strengeren Regeln, damit Fehler, auch als Fehler bezeichnet, weniger wahrscheinlich in Programme gelangen.

* Python, eine elegante Sprache, die bei Wissenschaftlern beliebt ist, sowohl mächtig als auch eine gute Muttersprache.

* Ruby, eine intuitive Sprache, deren Aussagen oft fast wie geschriebenes Englisch lesen.

* Go, eine einfache, leistungsstarke Sprache, die sich besonders bei parallelisierten Programmen auszeichnet, d. H. Programmen, die so geschrieben sind, dass mehrere Funktionen gleichzeitig unabhängig voneinander ausgeführt werden.

* Swift, eine neue Sprache, die zum Schreiben für Telefone und andere Geräte verwendet wird, die von einer Milliarde Menschen verwendet werden.

* Rust, die als Ersatz für C gedacht ist und gefährliche Fehler weitaus weniger wahrscheinlich macht.

* PHP, eine einfache Sprache für Internet-Server.

* Lisp, eine sehr alte Sprache mit einem grundlegend anderen funktionalen Programmieransatz.

* SQL, eine ganz andere Sprache, mit der Daten aus strukturierten und hocheffizienten Datenspeichern abgerufen werden, die als Datenbanken bezeichnet werden.

* Assembler (oder Assembly), eine sehr kryptische, begrenzte, aber schnelle und leistungsstarke Sprachfamilie, bei der eine direkte Beziehung zwischen den Sprachkonstrukten und dem Maschinencode des betreffenden Computers besteht; Es kann als halb kompilierter Code betrachtet werden.

## Entwicklung, Abhängigkeiten und Open Source

### Entwicklung

Der Prozess, eine einzelne, einfache Quellcodedatei in elektrische Impulse innerhalb eines Computers umzuwandeln, ist äußerst komplex. Wir begegnen dieser Komplexität mithilfe von Abstraktionsebenen. Eine als Befehlssatz bekannte Abstraktion ermöglicht die Verwendung des von einem einzelnen Compiler ausgegebenen Maschinencodes auf vielen verschiedenen Computertypen. Ein Autor des Quellcodes muss normalerweise nicht wissen oder sich darum kümmern, welche Art von Computer oder sogar welcher Befehlssatz zum Ausführen dieses Codes verwendet wird. Dies wird vom Compiler abstrahiert.

Moderne Software ist wiederum viel komplexer als ein einzelner Autor, der an einem einzelnen Programm für einen einzelnen Computer arbeitet. Es besteht aus vielen Autoren, die gleichzeitig an vielen Dateien innerhalb eines Projekts arbeiten und häufig mehrere Programmiersprachen verwenden. Darüber hinaus hängt jedes Projekt von anderen, separaten, in sich geschlossenen Projekten als Tools und / oder Komponenten ab, während diese Projekte selbst aktiv bearbeitet werden und wiederum von weiteren Projekten abhängig sind. Die elegante und effiziente Zusammenarbeit all dieser beweglichen Teile ist die Herausforderung der modernen Softwareentwicklung.

Wenn mehrere Quellcode-Autoren, auch als Softwareentwickler bezeichnet, an einem einzelnen Projekt arbeiten, verfügt jeder über einen eigenen Computer und eine Kopie des gesamten Projekts auf seinem Computer. Wenn sie jeweils Änderungen vornehmen, hat jeder eine andere Version desselben Projekts. Das Abgleichen mehrerer Versionen eines Projekts wird als Versionskontrolle bezeichnet. Es wird von der Versionskontrollsoftware verwaltet. in diesem Archiv von einer Software namens Git, nach der GitHub selbst benannt ist. Jedes Repository in diesem Archiv ist ein Git-Repository.

Git kann verschiedene Softwareversionen automatisch zu einer zusammenhängenden Form zusammenführen, ohne dass ein menschlicher Eingriff erforderlich ist. Git führt auch einen vollständigen Verlauf, mit dem Sie bei Bedarf auf eine frühere Version zurücksetzen können. Um Platz zu sparen, enthalten die Repositorys dieses Archivs im Allgemeinen keine Git-Historien.

Wenn mehrere Entwickler ein Projekt gleichzeitig auf mehreren verschiedenen Pfaden ausführen, wird dies als Verzweigung eines Projekts bezeichnet, und diese Pfade werden als Verzweigungen bezeichnet. Der vereinbarte Hauptzweig eines Projekts wird als Trunk oder Master-Zweig bezeichnet. Git bietet eine Einrichtung, mit der Entwickler die Unterschiede zwischen zwei Zweigen zusammenfassen und vorschlagen können, ihre mit den anderen zu verbinden. Dies wird als Pull-Anforderung bezeichnet. Die moderne Softwareentwicklung besteht hauptsächlich darin, ein Projekt zu verzweigen, die Software in Ihrer Niederlassung zu schreiben oder zu bearbeiten und nach Abschluss eine Pull-Anfrage zu senden, damit Ihre Arbeit wieder in die Hauptniederlassung aufgenommen wird.

### Abhängigkeiten

Grundsätzlich unterstützt jede Programmiersprache das Aufbauen auf der Arbeit anderer. Ohne die Wiederverwendung der Arbeit anderer wäre jedes Projekt enorm schwieriger und weitaus langsamer, und verschwindend wenige Projekte würden jemals in der realen Welt tatsächlich genutzt werden.

Wenn Projekt A Projekt B einschließen muss, damit A seine Arbeit erledigen kann, wird A als abhängig von Projekt B und B als Abhängigkeit von Projekt A bezeichnet. A kann viele Abhängigkeiten haben, von denen jede viele haben kann eigene Abhängigkeiten und so weiter. Darüber hinaus gilt jede Abhängigkeit für eine bestimmte Version oder einen bestimmten Versionsbereich eines bestimmten Projekts. Die vollständige Auflistung aller mehreren Abhängigkeitsebenen eines Projekts wird als Abhängigkeitsbaum bezeichnet.

Im Allgemeinen werden Abhängigkeiten in Quellcodedateien aufgeführt, normalerweise ganz oben, und jedes Mal, wenn der Compiler oder Interpreter eine Abhängigkeit findet, sucht er in einer Reihe vordefinierter Verzeichnisse danach. Da der Abhängigkeitsbaum für ein Projekt sehr komplex sein kann, wird er manchmal vollständig in einer einzelnen Datei innerhalb eines als Paketliste bezeichneten Projekts aufgeführt. Beispielsweise verfügen Ruby-Projekte möglicherweise über eine Gemfile für diesen Zweck, und JavaScript-Projekte verfügen möglicherweise über eine package.json-Datei. Auf diese Weise kann eine Art Tool, die als Paketverwaltungssoftware bezeichnet wird, alle Abhängigkeiten für ein Projekt gleichzeitig von einem oder mehreren Internet-Servern abrufen.

Bei diesem Archiv ist es wahrscheinlich, dass die Abhängigkeiten für ein bestimmtes Projekt an anderer Stelle im Archiv vorhanden sind. Um eine Abhängigkeit im Archiv zu finden, muss man zuerst den Namen der Abhängigkeit im Quellcode oder in der Paketliste ermitteln, deren genaue Details je nach Sprache und Framework variieren, und dann den Hauptindex in der Führungsrolle verwenden. oder in Abwesenheit der Indizes an der Vorderseite jeder Rolle, um zu bestimmen, auf welcher Rolle und auf welchem ​​Rahmen sich das betreffende Repository befindet.

### Open Source

Da das Ausführen eines Programms auf einem Computer nur den kompilierten Maschinencode erfordert, ist es möglich, diesen zu verteilen, während der Quellcode geheim gehalten wird. Dies ist als Closed-Source-Modell bekannt. In den frühen Tagen des Rechnens wurde der Quellcode normalerweise zusammen mit dem Maschinencode verteilt, aber als Software zu einer profitablen Branche wurde, wurde das Closed-Source-Modell immer häufiger.

Inzwischen hat sich herausgestellt, dass die Veröffentlichung von Quellcode für jedermann zum Kopieren, Verzweigen und Verbessern ein weitaus effektiverer Ansatz für die Softwareentwicklung ist. Mehr Leute, die den Quellcode eines Projekts lesen können, bedeuten mehr Leute, um mögliche Bedürfnisse und nützliche neue Funktionen zu identifizieren, mehr Leute, die das Projekt genug verstehen, um dazu beizutragen, mehr Leute, die Fehler erkennen und Korrekturen einreichen, und mehr Leute, die testen und verifizieren Dieser neue Code funktioniert.

Im Allgemeinen führt Closed Source zu kleineren, inselförmigen, fragmentierten Gemeinschaften, die Schwierigkeiten haben, neue und bessere Ideen zu finden und zu übernehmen. Open Source führt zu großen, miteinander verbundenen Communities, die sich gegenseitig dabei helfen, die Projekte des anderen zu wachsen, zu gedeihen und erfolgreich zu sein, die Arbeit des anderen als Abhängigkeiten zu nutzen und / oder ihren Code wiederzuverwenden und voneinander zu lernen. Open Source Software ist ein Toolkit für den kollektiven Einsatz der gesamten Menschheit. Je mehr und bessere Tools wir haben, desto schneller und besser können wir uns als Spezies weiterentwickeln.
