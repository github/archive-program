# GitHub Code Vault 指南

## 導言

GitHub Code Vault（GitHub 代碼保險庫）是由 GitHub Archive Program（GitHub 代碼永久保存計劃）設立的代碼檔案庫，旨在保存開源軟件以供未來使用。 壹年後或壹千年後，您可能會讀到這份指南，但無論如何，我們希望其內容甚至每個開源的概念都會對您大有裨益。

首先，這是壹個軟件檔案庫。 軟件即壹系列命令，用於控制計算機操作。 計算機則是可自動執行數學函數的設備，擁有讓人腦望塵莫及的迅疾速度及強大能力。 計算機可用於協助探索宇宙奧秘；憑借無所不在的信息網絡將全人類緊密相連；快速操控信號以傳輸聲音並將詳細的移動圖像投射至電氣屏幕；同時，以人類勞動力難以逾越的能力和精度操控強大機械。

然而，計算機壹旦脫離軟件，上述壹切功能均無從談起。 計算機精妙絕倫，但若無軟件，則毫無用處。 我們建立本檔案庫的目的在於，將所知曉的軟件知識和盤托出。

軟件是由復雜但人類可讀的命令序列編寫而成，各種不同風格的命令序列即稱為“編程語言”，因此壹個完整的軟件通常可稱為壹個“程序”。 然後，程序會轉換為可供計算機使用的二進制語言（由 0 和 1 構成）， 這壹過程即稱為“編譯”。

編譯後的軟件很難重新破解回原始程序形式，即源代碼，因此人們可對該原始形式進行保密，並獲得所有權。 開源軟件並非不同類別的軟件，但卻遵循另壹種理念。 開源的理念在於拒絕保密和所有權， 開源軟件程序面向任何有需求的人士免費開放，反之這些人士可協助改進相關程序，或用其創建更棒的新事物。

數以千計的人員可能自發形成群體，並集全體智慧方可開發出壹個開源項目。 正因如此，我們在此累積保存的所有開源軟件項目便是由不計其數的人們集思廣益而成。 盡管在某些特定項目裏，有些個人擁有特殊權利（如對源代碼的最新官方版本擁有批準或拒絕更改建議的權利），但是，沒有人對其擁有所有權。 每個人都有權隨時獲取和使用任何開源項目的完整副本，而且無需承擔任何代價或遭受任何懲罰。 這個過程即稱為“復刻”項目。

當很多人同時對源代碼進行編輯時，要對其所有更改進行記錄並整合，可謂極具困難。 為了解決這壹問題，名為“Git”的開源項目應運而生—— 即針對某個項目，將其所有添加和更改的完整歷史記錄完美整合至名為 Git 倉庫的實體中。 本檔案庫所存檔的正是此等倉庫。

本檔案庫由壹家名為“GitHub”的公司創建，該公司面向全球用戶提供服務：協助用戶存儲其所編寫的軟件程序，持續追蹤這些程序的相關更改，以及與他人協作改進和擴展這些程序。 GitHub 面向公共開源軟件的開發者提供免費服務， 而該等用戶基數高達數千萬。

為了充分利用本軟件檔案庫，我們將於以下篇章為您介紹所需知識和必備工具。 如果您無法了解或理解其中的部分或任何內容，請勿驚慌， 我們同時提供壹份指南，教您如何消化吸收個中內容。 如基於某些原因，您無法成功掌握這些內容，那麽您的子孫後代也可效勞。

## 使用本檔案庫所需的必備工具

基本上，僅需壹個“光源”和某種“放大鏡”，即可訪問本檔案庫。 然而，檔案庫中的大部分（非全部）數據均通過編碼和壓縮格式，得以嚴實封裝於膠卷中。 因此，將需大量計算方可讀取、解碼和解壓這些數據。 理論上，無需計算機也能完成此操作，但過程會是非常繁瑣且困難重重。

我們推測，您將無需我們就軟件、計算機和其它術語提供相應定義。 我們也猜想，妳們有自己的計算機。相較我們的機器，妳們的計算機可能先進得多，且基礎架構截然不同。 壹旦了解下方概述和指南，您將可輕易訪問所有數據。

當然，妳們的計算機可能更為落後，或者說妳們根本並未配備計算機。 倘若如此，我們早已備好壹個未壓縮、未編碼但人類可讀的數據膠卷，即所謂的“Tech Tree”（技術樹）。 Tech Tree 中包含涉及基礎科技、計算機和軟件的相關信息，希望假以時日，妳們將能夠使用這些知識重建計算機，以便能夠妥善利用本檔案庫中的開源軟件。

## 庫中內容

本檔案庫非常龐大，擁有高達約 24 萬億字節（詳見下方內容），可謂海納百川，真正實現民主決策。 數百萬人苦心編寫實用軟件並公開發布，人人均可獲取。 檔案庫中包含壹張“快照”，記錄了某壹瞬間，由 GitHub 用戶積極開發的所有公共軟件組合而成的壹張“全家福”。 這代表著，其中強勢融合有數以百萬計的各個倉庫。 我們希望，這樣浩瀚博大、科學民主的做法可吸引未來的歷史學家前來研究。

本檔案庫中所包含的倉庫純粹根據其最後壹次提交時間（即最後更新時間）及其星數確定。 （GitHub 用戶均有權對公共倉庫添加星標，以表示其喜愛或重視該倉庫。）“快照”的啟動時間為 2020/02/02，按我們的計時方式來算，即公歷 2020 年 2 月 2 日。 本檔案庫中包含的倉庫包括：前 80 天內有提交更改的所有倉庫；前 365 天內有提交更改的所有倉庫（至少有壹顆星）；以及 250 顆星及以上的所有倉庫，無需理會其最後更新日期為何時。

當然，就影響力和依賴性而言，並非所有倉庫都同等重要。 Tech Tree 中含有壹份索引及簡介，其中涵蓋本檔案庫中最重要的倉庫，並列出其所在的各個膠卷，以便確定那些最為實用的倉庫，而無需逐壹瀏覽全部幾百萬個倉庫。

## 檔案庫概述

本檔案庫共含有 201 個膠卷，其中包括壹個含有人類可讀信息和指引的“指南膠卷”和 200 個軟件存檔膠卷。 每個膠卷包含 65,000 個單獨的幀。 每個膠卷開頭的幀及“指南膠卷”內的幀均包含人類可讀文本和圖像。 膠卷的所有其它幀則含有以二維碼可視形式存儲的數字數據。

數字數據意味著以二進制作為最終存儲格式的數據，即 0 和 1。原因在於，計算機本身就是二進制，即通過分別對應 1 或 0 的“開”或“關”電信號進行控制。因此，相比其他方式，二進制數據更易於計算機識別。

人類可讀元數據存儲於每個膠卷的開頭，包含該膠卷本身的信息、所用二維碼編碼指南、用於解碼的軟件程序及壹份索引。 其中，該索引針對存儲在該膠卷上的每個文件，均列出其相應標題、起始幀號和檢驗和。

文件是連貫壹致的數據實體。 校驗和是計算中的唯壹值（稱為哈希函數），運行於文件的整體內容上，以確保其內容未受到損壞或破壞；本檔案庫中使用的哈希函數稱為"SHA-1"。

每個二維碼由壹個個白色或黑色小方塊組成，該等小方塊幾乎占據膠片的整個幀。 使用二維碼的原因在於，其比人類可讀的文本更緊湊而可靠。 二維碼可解碼為二進制數據，即壹系列 1 和 0。

就將二進制數據轉換為有意義的信息而言，解碼僅是第壹步。 二進制數據是壓縮數據，即通過壓縮的方式來節省空間。其中的原理就如我們會寫“128xA”，而不會將字母 A 重復寫 128 遍壹樣。 解碼後，其還須進行解壓。

解壓後的結果稱為壹個“存檔文件”，即包含壹個軟件項目倉庫全部內容的單個文件。 大部分倉庫會包括許多文件，因此該存檔文件就像是壹本書，其內包含眾多不同章節；或像是壹個盒子，其內同樣包含許多其它盒子。 通常建議在訪問存檔文件之前，將其解包到組件文件中，但該做法並非絕對必要。

最後，每個組件文件均為其各自的二進制數據集，即 1 和 0。 若您知道數據格式，即可理解該數據。 例如，在本檔案庫最常見的“UTF-8”格式中，1 和 0 被分成八位壹組，稱為“字節”，字節 01000001 代表字母 A；三個字節 01101001 01101110 01110100 即代表單詞 int；兩個字節 11000011 10000011 則代表字母 Ã（上面帶有波浪號的 A）。

此數據存檔過程——將二進制文件先壓縮，再編制二維碼，最後打包成存檔文件——顯然會比簡單書寫人類可讀的文本要復雜得多。 提取檔案的過程，即從二維碼到壓縮的二進制數據；從壓縮到解壓；從存檔文件到多個文件；從文本文件到人類可讀文本，也同樣復雜。 然而，此復雜過程相比其它方式，可以計算機可讀的相對簡單方式存儲更多數據。

若因為如此復雜而給您造成困難和導致高成本，我們深表歉意。但我們猜測，若真如此，本指南及人類可讀的 Tech Tree 將會降低復雜性，而且可能比存檔內容更實用，至少當計算機足夠先進時，本檔案庫的數據復雜性會顯得易於操作。

## 文件、目錄、倉庫和數據格式

我們將討論本檔案庫在邏輯上的劃分方式，這可能極具指導意義。 我們會特別討論文件、目錄和數據格式，這些可能十分實用。

壹組數據組合壹起，形成符合邏輯的實體並帶有單壹名稱，即成為壹個文件。您可以將數據想象成沙子，文件就是僅可用來裝沙子的袋子。 目錄是文件的集合。您可以將其看作是壹種僅可裝進其他袋子的袋子。 以此類推，每個倉庫包含壹個外層目錄，稱為“根目錄”，其中含有壹系列文件和/或壹系列目錄。 每個目錄本身又包含文件和目錄。

我們選擇此結構的原因在於，將文件分成不同群組比單壹的文件集合更易於管理。 外層目錄下的某個文件之識別符包含其所有從屬目錄的名稱：從根目錄開始，緊接著是其本身的名稱，各個名稱中間用字符 / 隔開。 例如，在根目錄下有壹個名為 README.md 的文件，其識別符為 /README.md，而識別符為 /public/www/index.html 的文件即 index.html 文件，位於根目錄內“public”目錄下的“www”目錄中。

每個倉庫又含有兩個名字，由壹個分隔符分開，這個分隔符在本檔案庫中為“_ ”或稱為“下劃線字符”。 （此前，曾使用“/”或斜杠，但也用於指示目錄，因此為了稍作區別，我們使用“_”。）第壹個名字是擁有該倉庫的 GitHub 帳戶名稱；第二個名字則是該單個倉庫的名稱。 將倉庫和文件標識符兩相組合，即可用於單獨標識本檔案庫中的單個文件。 例如，在本檔案庫內的 GitHub 帳戶"rezendi"中，有個倉庫"ykarma"。其內，目錄"web"下的文件"package.json"可單獨標識為 rezendi_ykarma 中的 /web/package.json。

各種類型的文件具有不同用途。 GitHub 檔案庫包含大量文本文件，這意味著，這些文件中的數據代表書面語言。 大多數軟件均采用文本文件進行編寫，其中包含高度結構化的文本，稱為“源代碼”。 壹種稱為“編譯器”的特殊程序能將人類可讀的源代碼轉換為計算機可讀的指令，即編譯代碼或機器代碼。

文本文件以外的文件，如用於顯示可視圖像或包含編譯代碼的文件，則通常指代二進制文件。 遺憾的是，此術語具有誤導性，畢竟文本文件最終也是由 1 和 0 構成。 為此，我們將文本文件以外的文件稱為“非文本文件”。

使用 1 和 0 代表人類書面語言的方法為數眾多。 由於歷史原因，大多數源代碼最初是由拉丁語腳本編寫而成。 拉丁語腳本具有 26 個基本字符，用於表示可口頭表達的單詞，每個單詞設有兩種形式，即大寫和小寫。 此外，該腳本還有 10 位數可用來表示數字。 拉丁語腳本連同用於指示結構和其他概念的各種其他關聯符號，均以 1 和 0 的格式（稱為"ASCII"）進行編碼。該格式可表示 128 個不同字符，並且由於歷史原因，多年以來曾在大多數軟件中占主導地位。

然而，在人類以書面語言表達自我的眾多方式中，拉丁語腳本僅為壹個小分支。 為了支持其他腳本，同時允許所有編寫目的為使用 ASCII 的軟件，在無需更改的情況下繼續運行，（此概念稱為“向後兼容”），"UTF-8"數據格式得以隨之引入。

ASCII 仍然是源代碼中最常見的格式， 本檔案庫的每個膠卷均包含壹份 ASCII 字符指南。 ASCII 是 UTF-8 的子集，換言之，所有 ASCII 編碼同時也是 UTF-8 編碼。 此外，本“指南膠卷”還包含壹份涉及所有 UTF-8 字符的規範。 本檔案庫中幾乎所有文本文件均應使用 UTF-8 進行編碼。

非文本文件包括用於表示圖像和格式化文檔的文件。 按照通用習慣，文件名會以字符“.”及後綴結尾，以指示其文件類型。 例如，以 .jpg 結尾的文件可能是 JPEG 圖像文件；以 .PNG 結尾的文件則可能是“可移植網絡圖形”圖像文件；而以 .pdf 結尾的文件可能是“可移植文檔格式”文件。

對於文本文件，尚無單壹後綴可用於指示。 然而，源代碼的後綴更多用於指示該代碼編寫所使用的編程語言或標記語言。 涉及編程語言和標記語言的相關內容，將會在下方篇章進行更詳盡描述。

## 如何提取檔案庫的內容

下面，我們將簡要介紹如何將某個存檔的倉庫解包成各個構成文件。 如前所述，這壹過程包括：

1.  找到倉庫數據所在存檔的具體膠卷和幀。

2.  將那些幀上由黑、白、灰像素區域構成的二維碼解碼為二進制文件，即壹個由（少則數千個、常常高達數百萬個）1 和 0 構成的序列。

3.  將二進制文件解壓為壹個更長但已解壓的存檔文件。

4.  將存檔文件解包為其所包含的不同子文件。 但註意，存檔數據可能淩亂，但即便無此步操作，通常也能讓人理解。

5.  最後，若為文本文件，將每個子文件均轉換為書面字符（子文件本身的 1 和 0 序列可長可短）。

### 找出倉庫數據存檔所在的具體膠卷和幀

每個膠卷最先以壹段空膠片為引導，然後是“零點參考幀”，即壹個空幀，其中的壹角帶有純黑色矩形。 下壹個人類可讀的幀是“控制幀”，其含有此膠卷的相關信息。 接著是壹個“內容目錄”，其又包含壹個“用戶數據文件”的列表。

在這個膠卷上的每個倉庫即為“用戶數據文件”的其中之壹。 此列表包含每個文件的壹個唯壹 ID、壹個文件 ID 和壹個名稱。 例如，Python 帳戶的 CPython 倉庫文件 ID 可能為 12345，而名稱為 python_cpython.tar。

“用戶數據文件”列表後緊隨著是“數字數據位置”列表。 此列表包含文件 ID、壹個起始幀、壹個起始字節、壹個結束幀和壹個結束字節。 因此，仍然假設有 CPython 倉庫，此列表中 ID 為 12345 的文件項起始幀可能為 054321，起始字節為 03210321，結束幀為 054545，結束字節為 12321232。

這意味著，要獲取 CPython 倉庫中的數據，需前往此膠卷的幀 54321。 然後，將起始幀 54321 到結束幀 54545 的所有幀解碼為二進制值，具體方法如下所述。 這樣壹來，您會得到編號從 54321 到 54545 的 225 個數據，其中前面的壹些數據為空。 丟棄前面非空數據中的前 3210320 字節， 按順序添加所有“中間”的數據， 最終添加從最後壹個 54545 號數據開始的前 12321232 字節。 現在，您已組合完成完整的 CPython 倉庫，得到壹個壓縮的存檔文件。

### 將二維碼解碼為二進制文件

有關如何將膠片裏的幀解碼成為二進制數據的詳細信息，請見人類可讀的“說明信息”。該信息可在“內容目錄”中找到，具體位置見本檔案庫每個膠卷的開頭處。 每個膠卷中都有該信息，因此即使從本檔案庫中單獨提取壹個膠卷，也可對其內容進行破解。 “說明信息”依次包括如下內容：

1.  GitHub 代碼永久保存計劃指南（即本文檔）

2.  GitHub 描述性索引，即該膠卷上所有倉庫的壹份列表和簡介

3.  “說明信息”描述

4.  數字保存及如何檢索數字，即對數字檢索細節的概覽

5.  存儲介質介紹

6.  數據檢索技術

7.  通用保存膠卷結構（膠卷格式）

8.  通用 4K 幀格式說明

9.  開箱資料庫說明（針對二維碼）

10. 開箱資料庫源代碼

11. ASCII 數據格式規範

12. C 編程語言規範

13. TAR 存檔文件源代碼

14. PDF 源代碼

15. XZ 文件格式規範（用於壓縮/解壓縮，如下所述）

其中，第六項“數據檢索技術”文檔，針對使用掃描儀捕捉膠片中單個數字編碼幀上的數據並將其轉換為適合計算機分析的形式，介紹了相關要求和流程。 第八項“通用 4K 幀格式說明”提供有計算機獲取掃描圖像並轉換為二進制數據的技術信息，包括源代碼。

基本而言，在無計算機的情況下，理論上可將壹個倉庫從二維碼編碼數據轉換為二進制數據。 但是，這會非常困難，而且可能需要壹個組織良好的群體付出大量努力並耗上數周，甚至數月、數年時間方可實現。 由於這些倉庫的內容均為設計用於在計算機中運行的軟件，所以在沒有計算機的情況下，其用途微乎其微。

如果本檔案庫的繼承者沒有計算機，則應該確保檔案庫完好、安全，直至成功配備計算機為止。 建立人類可讀 Tech Tree 的其中壹個目的在於，當此情況確實出現時，可協助加快技術及計算機發展。 （其他目的還包括將技術和發展匯編起來，以供未來的歷史學家研究。）

### 將存檔文件解包為其所包含的不同子文件

每壹個倉庫的二進制文件均采用壹種稱為 TAR 的格式，TAR 即“膠帶存檔”。 壹個 TAR 文件主要由壹系列文件組成，這些文件首尾相接，就像利用膠帶將不同紙片粘貼壹起，形成卷軸。 TAR 文件可能包括壹系列大小不壹的文件，並各自劃分在不同數量的目錄和子目錄中。

TAR 文件中每個子文件的開頭均為 512 字節的文件頭記錄，充當上述卷軸比喻中的膠帶作用。 這些文件頭記錄包含有關該文件的信息，如文件名和文件大小。 存檔文件的結尾會用至少兩個連續的 512 字節塊來指示。

基本而言，TAR 文件是文件集合，而這些文件之間會以文本記錄作為連接。因此，若 TAR 文件包含的全為文本文件，那麽該 TAR 文件本身也可認為是壹個文本文件。 若其包含混合類型文件，則可認為這是壹個文本文件，但該文本文件同時包含結構化、有意義的文本（構成文本文件）和無法理解的無用數據（構成非文本文件）。

我們可將 TAR 文件嵌套進 TAR 文件，就像在容器中裝入另壹容器，而這正是大部分存檔數據的存儲方式。 無論哪個倉庫，其外層 TAR 文件都將至少包含如下內容：

* 壹個名為 META 的未壓縮元數據文件，其包含倉庫名稱、帳戶名、說明、語言、星數、復刻數
* 壹個名為 COMMITS 的壓縮文件（如下所述），包含該倉庫有史以來的更改記錄
* 壹個名為 repo.tar.xz 的文件，是包含實際倉庫內容的壓縮 TAR 文件

其它諸如 wiki、gh-page、issue 和 pull request 等元數據也可能包含在不同壓縮文件中。

如要查看 TAR 文件以及用於對其進行編碼和解碼的相關軟件之詳細信息，請見本檔案庫各個膠卷中的“說明信息”。

### 將壓縮文件解壓為已解壓的可讀文件

為了將盡可能多的倉庫和數據包括入內，大部分數據均經過壓縮。 壓縮即意味著，在大量數據中應用某種模式和重復性方法，以少量數據代表大量數據。 例如，如果您確信讀取器能理解 9a 表示未壓縮文本 aaaaaaaaa，則只需編寫壓縮文本 9a，而無需將該字符連續書寫九次。

高效壓縮算法比這要復雜得多，但道理完全壹樣。 本檔案庫使用壹種名為“XZ”的壓縮程序，其所使用的算法稱為“LZMA”。 每個膠卷中的第二個數據文件包含用於 XZ 的源代碼和文檔，並位於壹個未壓縮 TAR 存檔文件中，如下所述。 （第壹個數據文件包含以各種人類書面語言書寫的《世界人權宣言》。）

LZMA 將“LZ77”算法和“區間編碼”算法亮相結合。 按 LZ77 算法，重復的數據會替換為壹個引用，指向先前出現的該數據。 例如，為了達到極致簡化的目的，如果壹個 80 字節的短語出現兩次，中間間隔 400 字節，那麽其第二次出現時，為了壓縮數據，該算法基本上會表達為"重復 400 字節之前出現的 80 字節"。 基本上，區間編碼是將壹整條消息轉換為壹個極長的數字，而此數字也可進行編碼。

用於解壓數據的算法具體步驟詳見每個膠卷中第二個數據文件內包含的 XZ 源代碼。 如上所述，理論上，可進行手工加壓，但那將是異常費時費力的過程。 實際上，我們通常需要壹臺計算機。

### 將各個單獨文件轉換為書面字符

過去壹千年間，人類已使用多種書面字符。 本檔案庫中，用於代表這些字符的 1 和 0 編碼方式稱為“UTF-8”。 壹個 UTF-8 字符（即壹個書面符號）在任何時候都會占用 1-4 字節的二進制數據。

鑒於歷史原因，壹種叫“ASCII”的字符（和概念）集合是最高效的編碼方式（每個字符 1 個字節），畢竟在軟件開發的初始時段以及最初開發地內，這是應用最廣的壹種字符集合。 非 ASCII 字符均使用 2 個或以上的字節對每個字符進行編碼。 本檔案庫中的大多數文本文件均為 ASCII 格式，但也存在大量其他格式的文件。 更多文件則是采用大部分 ASCII 字符加上偶爾幾個非 ASCII 字符的方式組合而成。

有關 ASCII 的詳細介紹，請見本檔案庫每個膠卷中的“說明信息”。 UTF-8 的詳細規範請見“指南膠卷”。 本檔案庫每個膠卷中的第壹個數據文件均包含以各種人類書面語言書寫的《世界人權宣言》， 作為壹種翻譯工具以及 ASCII 和 UTF-8 的示例。

## 文件種類

出於不同目的，我們創建出眾多不同種類的文本文件。 出於本檔案庫之目的，這裏的首要文件種類為源代碼。 源代碼是非常密集且極致結構化的文本，其中的“{”和“;”等符號均具有重要意義。

編寫源代碼是為了讓編譯器讀取，這點至關重要。 編譯器也是壹種軟件，換言之，源代碼的編寫目的在於，讓計算機加以讀取。 同理，編寫優秀代碼也為了讓其他人類加以理解。當然，這些人員需擁有軟件方面的技能或接受過軟件領域的教育；但是，只有當編譯器能理解代碼時，這壹切才有意義。

編譯器通過復雜的序列（參見 Tech Tree）將源代碼轉換為由 1 和 0 組成的序列，計算機據此執行代碼所描述的功能和活動。 舉壹個非常簡單的例子：

_(int i=0; i<5; i++) { }_

以上這行代碼將經由編譯器轉換為壹系列二進制指令並提供給計算機，令計算機中名為“寄存器”的小部件將其值設為 0，隨後再將該值遞增為 1、2、3 和 4。 （以上示例並非意指壹行有用代碼；這僅為了說明利用源代碼運行軟件是壹個多層次過程。）

其它文本文件類型，如 JSON、XML 和 HTML，則用於存儲計算機的所用數據（而非命令）。 人類壹般也能將其讀懂，但相較於像本文件這樣的低結構化敘事性文本，其結構化格式令其更青澀難懂。

其它大部分文本文件類型最終均為了形成人類可讀的文件。 有些文件較為簡單，主要是非結構化的文本，比如您正在閱讀的這壹文件。 在本檔案庫中，您將常常碰到 Markdown 這壹文件類型。此類文件以 .md 為文件擴展名，這是壹種中間形式，意味著在其原始形式下，具有人類可讀性。同時，其也得到結構化處理，以便計算機將其格式化為視覺上更美觀、更有用的布局。 本檔案庫中的大部分倉庫都含有 README.md 的 Markdown 文件，壹般作為倉庫的初始介紹，描述該倉庫是什麽、為何存在及如何使用等問題。

下文將簡要介紹非文本文件的最常見形式，這對您可能同樣重要。 編譯代碼為非文本類型， JPG 和 PNG 文件是以數字格式編碼的圖像文件，而 MP3 和 WAV 文件則是編碼的音頻文件。 PDF 文件為編碼文檔，具有簡潔完美的格式。 上述 ZIP 和 TAR 文件屬於容器文件，可能包含壹個或多個其它文件。

## 人類語言和編程語言

### 人類語言

在今天，人類使用的書面語言多達數千種，而口頭語言則更多。 其中大部分語言的使用人群均相對較少，但至少有二十種語言構成至少 6 千萬人的母語或第二語言。

英語和漢語構成全球使用範圍最廣的語言。 出於歷史原因，多年以來，大部分軟件開發僅出現在英語的母語國家內。因此，英語曾壹度是軟件的默認語言。 大部分編程語言在其語句中均使用英語單詞。 編寫本檔案庫指南所使用的第壹語言也是英語。

我們無法保證本檔案庫的傳承人懂英語，但英語似乎極有可能會世代相傳。 倘若以其他語言編寫的指南比較實用，我們將會在每個膠卷的開頭提供壹個未壓縮的 UTF-8 文件，其中包含超過 500 種語言版本的《世界人權宣言》，而且這在 Tech Tree 中也能找到。 該《宣言》是我們這壹時代每個人所擁有的權利和自由。無論如何，絕不可剝奪這些權利和自由。

### 編程語言

編程語言是人類用來向計算機傳達指令的語言， 軟件正是使用這種語言來加以表達。 其他（受過訓練）的人也應能讀懂由編程語言編寫的軟件，但這是次要目標。

編程語言包含壹系列預定義的元素，其中大多數為單詞，通過結構化的排列，指示計算機以指定方式執行指定操作。 這種指令的集合稱為“程序”，也叫“源代碼”。 源代碼基本上是以“凍結”的書面形式存在之軟件。

程序通常可分成離散的步驟，稱為語句。這些步驟又分組到稱為“函數”的集合中。 壹個完整的程序可能僅包含在壹個文件中，也可能分布在數千個文件中。

世界上有數百種不同的編程語言，采用各不相同的形式、方法和原理。 有些編譯為各個單獨的二進制文件，然後由計算機執行；有些稱為“直譯”語言，經過有效編譯即可直接運行，無需中間階段。 大多數現代語言包括預先編寫的函數庫，而且此類函數庫的內容極為豐富且詳細。 當今最流行的編程語言包括：

-   C 語言——最古老、最快速、最通用、最強大的語言之壹，在某些方面十分簡單，但在其他方面卻極為受限，而且並不那麽直觀，也不太易於閱讀或學習。

-   C++ 語言——在 C 語言的基礎上，進化而來的壹種語言，具有更復雜、抽象和強大的特點。

-   C# 語言——進壹步進化的語言，並非編譯成二進制機器代碼，而是直譯式的"運行時"。

-   Java 語言——與 C# 語言類似（但早於 C# 語言），可能是當今使用最廣泛的語言。

-   JavaScript 語言——與 Java 語言大不相同，盡管名稱相似，也稱為"ECMAScript"，最初完全用於 Web 瀏覽器，即從壹臺遠程計算機（稱為“互聯網服務器”）獲取數據，經過解譯後將數據顯示出來的壹種程序；然而，今天，JavaScript 語言同時廣泛用於那些服務器。

-   TypeScript 語言——JavaScript 語言的壹種形式，具有更嚴格的規則，因此錯誤（也稱為漏洞）不太可能進入程序。

-   Python 語言——在科學家中流行的壹種優雅語言，既強大又好用的第壹語言。

-   Ruby 語言——壹種直觀的語言，通常，其語句讀起來幾乎像書面英語。

-   Go 語言——壹種簡單而強大的語言，在並行化程序方面尤為突出。並行化程序即通過程序編寫，使多個函數可在同壹時間獨立運行。

-   Swift 語言——用於針對十億人均使用的手機和其它設備，而特意編寫的壹種新語言。

-   Rust 語言——旨在替換 C 語言的語言，將危險漏洞大幅減少。

-   PHP 語言——壹種直截了當的語言，可用於互聯網服務器。

-   Lisp 語言——壹種非常古老的語言，采用根本不同且功能優先的方法進行編程。

-   SQL 語言——壹種非常不壹樣的語言，用於從結構化和高效數據存儲庫（稱為“數據庫”）中獲取數據。

-   Assembler（或叫 Assembly）——壹個非常晦澀、受限但快速、強大的語言系列，其語言構造和計算機的機器代碼之間具有直接關聯；可視為壹種半編譯代碼。

## 軟件開發、依賴項和開源

### 軟件開發

獲取壹個簡單的源代碼文件並將其轉換為計算機中的電脈沖信號，這個過程極其復雜。 為了解決這種復雜性，我們使用抽象層。 壹個抽象層稱為壹個“指令集”，可使由編譯器輸出的機器代碼用於各種各樣的計算機。 源代碼的作者壹般無需知道或在意將使用何種類型的計算機（甚至何種指令集）運行代碼；我們利用編譯器進行抽象處理。

相較於壹位作者編寫單個程序並用於壹臺計算機的簡單模式而言，現代軟件更顯復雜。 在壹個項目中，現在軟件包含多名作者，他們同時編寫多個文件，並常常使用多種編程語言。 此外，每個項目均依賴其它獨立的各個項目作為其工具和/或組件，而這些其它項目本身則需要其他項目使其運行，因而又依賴於別的項目。 因此，現代軟件開發的難點在於，讓所有這些活動的零部件巧妙高效地共同運轉。

當多名源代碼作者（也稱為“軟件開發人員”）共同參與同壹項目開發時，每位作者均有自己的計算機，而且在其計算機裏都有整個項目壹份副本。 如果他們每個人都對項目進行更改，則同壹個項目會存在多個不同版本。 對同壹項目的多個版本進行協調，這個過程稱為“版本控制”， 可由版本控制軟件管理；在本檔案庫中，是由名為 Git 的軟件進行管理，而 GitHub 的名字正源於此。 本檔案庫中的每個倉庫稱為壹個 Git 倉庫。

Git 會自動將不同版本的軟件合並成連貫壹致的形式，僅需極少人工幹預即可。 Git 還會保存完整歷史記錄，如此壹來，即可讓您在需要時找回原先版本。 但是，為了節約空間，本檔案庫中的倉庫壹般不包含 Git 歷史記錄。

當多名開發人員同時在多個不同通道上開發壹個項目時，這稱為對項目進行“分支”，而這些通道均稱為“分支”。 壹個項目中公認的主分支稱為“主幹”或“默認分支”。 Git 提供壹個設施，開發人員可用其匯總兩個分支之間的不同之處，並建議將其合並為其它分支， 這即稱為“拉取請求”。 現代軟件開發主要包括：對項目進行分支、編寫或編輯分支上的軟件，以及在完成後提交拉取請求，以便重新歸並回默認分支。

### 依賴項

基本而言，每種編程語言均支持在他人編寫的代碼基礎上建立新的代碼。 如果無法使用他人的代碼，每個項目將會變得更為困難，且速度要緩慢得多，極少項目會真正在現實世界中得以應用。

如果項目 A 需要包含項目 B 才能運行，我們就稱之：項目 A 依賴於項目 B，項目 B 是項目 A 的壹個依賴項。項目 A 可以有許多依賴項，每個依賴項也可以有自己的依賴項，以此類推。 此外，每個依賴項都是針對壹個指定項目的壹個特定版本或版本範圍。 壹個項目會有多層依賴項，將其全部細目列出即為“依賴項樹”。

壹般來說，在源代碼文件內，通常在最開頭位置，會列出依賴項。每當編譯器或直譯器找到壹個依賴項時，會從壹系列預定義的目錄中查找。 由於壹個項目的依賴項樹可能非常復雜，有時在壹個項目中，其完整的依賴項樹需要壹個單獨文件，稱為壹個“包列表”。 例如，Ruby 語言項目為此可能有壹個 Gemfile 文件，而 JavaScript 語言項目可能有壹個 package.json 文件。 這樣壹來，壹種叫“包管理軟件”的工具可從壹個或多個互聯網服務器中壹次性獲取壹個項目的所有依賴項。

就本檔案庫而言，任何指定項目的依賴項均可能存在本檔案庫中的某個地方。 要在檔案庫中找到壹個依賴項，您需先在源代碼或包列表中找到該依賴項名稱，其具體詳情可能會因語言和框架而不同。然後，使用“指南膠卷”中的主索引（如無主索引，則使用每個膠卷前面的索引）確定應去哪個膠卷和哪個幀中找到該倉庫。

### 開源

由於在計算機上運行程序僅需要經編譯的機器代碼，因此在傳播機器代碼時仍可對源代碼進行保密。 這種做法稱為“閉源”模型。 在計算技術發展的早期，源代碼壹般隨著其機器代碼壹同傳播，然而後來軟件可為行業帶來盈利，閉源模型也隨之越發常見。

再後來，人們意識到將源代碼公開，允許任何人復制、分支和改進，是壹種更有效得多的軟件開發方式。 讓更多人讀取某個項目的源代碼意味著，更多人發現可能的需求和有用的新功能，更多人可充分了解該項目並為其錦上添花，更多人可能找到漏洞並提交解決方案，更多人可以測試和驗證新代碼的有效性。

總之，閉源會導致群體變得微小、狹隘、破碎，人們從中難以發現和應用更新的更佳理念。 相反，開源有助營造廣大的互聯社會。在其中，人人均可幫助他人發展、壯大項目，以獲取成功；也可使用他人代碼作為依賴項及/或重新利用其代碼，實現互相學習。 開源軟件是供所有人類集體使用的工具包，我們擁有越多、越好的工具，人類種群的發展進程才會越快、越好。
